//@version=6
indicator("Universal Backtester", overlay=true, max_labels_count=500, max_boxes_count=500)

// =============================================================================
// SETTINGS
// =============================================================================

// ─────────────────────────────────────────────────────────────────────────────
// SIGNAL SOURCE
// ─────────────────────────────────────────────────────────────────────────────
groupSignal = "SIGNAL SOURCE"
signalSource = input.string("External", "Signal Source", options=["External", "Manual Condition"], tooltip="External: Connect to another indicator's plot\nManual: Use built-in conditions", group=groupSignal)
enableLong = input.bool(true, "Enable Long Trades", tooltip="Allow Long/Buy trades", group=groupSignal)
enableShort = input.bool(true, "Enable Short Trades", tooltip="Allow Short/Sell trades", group=groupSignal)

// External signal inputs (connect to other indicator's plots)
extLongSignal = input.source(close, "Long Signal Source", tooltip="Connect to indicator's Long/Buy signal plot (1 = signal, 0 = no signal)", group=groupSignal)
extShortSignal = input.source(close, "Short Signal Source", tooltip="Connect to indicator's Short/Sell signal plot (1 = signal, 0 = no signal)", group=groupSignal)
extLongThreshold = input.float(0.5, "Long Signal Threshold", tooltip="Signal triggers when source crosses above this value", group=groupSignal)
extShortThreshold = input.float(0.5, "Short Signal Threshold", tooltip="Signal triggers when source crosses above this value", group=groupSignal)

// Entry price source
entryPriceSource = input.string("Custom Source", "Entry Price Type", options=["Close", "Open", "High", "Low", "HL2", "HLC3", "OHLC4", "Custom Source"], tooltip="Price used for entry", group=groupSignal)
extLongEntryPrice = input.source(close, "Long Entry Price Source", tooltip="Connect to RZ S1 (Support) for Long entries", group=groupSignal)
extShortEntryPrice = input.source(close, "Short Entry Price Source", tooltip="Connect to RZ R1 (Resistance) for Short entries", group=groupSignal)

// ─────────────────────────────────────────────────────────────────────────────
// TP/SL SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupTPSL = "TP / SL SETTINGS"
tpType = input.string("ATR", "TP Type", options=["ATR", "Percent", "Fixed Points", "Custom Source"], group=groupTPSL)
slType = input.string("ATR", "SL Type", options=["ATR", "Percent", "Fixed Points", "Custom Source"], group=groupTPSL)

// ATR Settings
atrLength = input.int(14, "ATR Length", minval=1, group=groupTPSL)
tpAtrMult = input.float(2.0, "TP ATR Multiplier", minval=0.1, step=0.1, tooltip="TP = Entry ± (ATR × Multiplier)", group=groupTPSL)
slAtrMult = input.float(1.0, "SL ATR Multiplier", minval=0.1, step=0.1, tooltip="SL = Entry ∓ (ATR × Multiplier)", group=groupTPSL)

// Percent Settings
tpPercent = input.float(2.0, "TP Percent %", minval=0.1, step=0.1, group=groupTPSL)
slPercent = input.float(1.0, "SL Percent %", minval=0.1, step=0.1, group=groupTPSL)

// Fixed Points Settings
tpPoints = input.float(100, "TP Points", minval=1, group=groupTPSL)
slPoints = input.float(50, "SL Points", minval=1, group=groupTPSL)

// Custom Source (connect to RZ levels etc)
extTpSource = input.source(close, "Custom TP Source", tooltip="Connect to TP level from indicator", group=groupTPSL)
extSlSource = input.source(close, "Custom SL Source", tooltip="Connect to SL level from indicator", group=groupTPSL)

// ─────────────────────────────────────────────────────────────────────────────
// ACCURACY SETTINGS (Lower Timeframe)
// ─────────────────────────────────────────────────────────────────────────────
groupAccuracy = "ACCURACY SETTINGS"
useLowerTF = input.bool(true, "Use Lower Timeframe Check", tooltip="Check lower timeframe to determine if TP or SL was hit first (more accurate but less history)", group=groupAccuracy)
lowerTF = input.string("5", "Lower Timeframe", options=["1", "3", "5", "15", "30", "60"], tooltip="Timeframe in minutes for accuracy check (5m recommended for 15m chart)", group=groupAccuracy)
signalBarMode = input.string("TP First", "Signal Bar Conflict", options=["TP First", "Pessimistic", "Open-Based"], tooltip="On SIGNAL candle when both TP+SL hit: TP First recommended (cross = good direction)", group=groupAccuracy)
nextBarMode = input.string("Pessimistic", "Next Bar Conflict", options=["Pessimistic", "Optimistic", "Open-Based"], tooltip="On candles AFTER signal when both TP+SL hit", group=groupAccuracy)

// ─────────────────────────────────────────────────────────────────────────────
// FEES SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupFees = "FEES SETTINGS"
useFees = input.bool(true, "Enable Fees", group=groupFees)
feeType = input.string("Percent", "Fee Type", options=["Percent", "Fixed"], group=groupFees)
entryFee = input.float(0.04, "Entry Fee %", minval=0, step=0.01, tooltip="Fee on entry (e.g. 0.04% for Binance maker)", group=groupFees)
exitFee = input.float(0.04, "Exit Fee %", minval=0, step=0.01, tooltip="Fee on exit (e.g. 0.04% for Binance maker)", group=groupFees)
fixedFeePerTrade = input.float(0, "Fixed Fee per Trade", minval=0, tooltip="Fixed fee amount per trade", group=groupFees)

// ─────────────────────────────────────────────────────────────────────────────
// POSITION SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupPosition = "POSITION SETTINGS"
initialCapital = input.float(10000, "Initial Capital", minval=100, group=groupPosition)
leverage = input.float(20, "Leverage", minval=1, maxval=125, step=1, tooltip="Trading leverage (e.g., 20x)", group=groupPosition)
useCompounding = input.bool(true, "Use Compounding", tooltip="Position size based on current equity (true) or initial capital (false)", group=groupPosition)
positionSizing = input.string("Percent", "Position Sizing", options=["Percent", "Fixed", "Risk-Based"], group=groupPosition)
positionPercent = input.float(5, "Position Size %", minval=0.1, maxval=100, step=0.1, tooltip="Percent of equity per trade (before risk adjustment)", group=groupPosition)
fixedPositionSize = input.float(1000, "Fixed Position Size", minval=1, group=groupPosition)
maxRiskPercent = input.float(2, "Max Risk per Trade %", minval=0.1, maxval=50, step=0.1, tooltip="Maximum equity loss per trade. Position size reduced if SL would exceed this.", group=groupPosition)
useMaxRiskCap = input.bool(true, "Enable Max Risk Cap", tooltip="Automatically reduce position if SL exceeds max risk", group=groupPosition)
allowPyramiding = input.bool(false, "Allow Pyramiding", tooltip="Allow multiple positions at once", group=groupPosition)

// ─────────────────────────────────────────────────────────────────────────────
// DASHBOARD SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupDashboard = "DASHBOARD"
showDashboard = input.bool(true, "Show Dashboard", group=groupDashboard)
dashboardPosition = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=groupDashboard)
dashboardSize = input.string("Normal", "Dashboard Size", options=["Tiny", "Small", "Normal", "Large"], group=groupDashboard)
showTradesOnChart = input.bool(true, "Show Trades on Chart", group=groupDashboard)
showTPSLLines = input.bool(true, "Show TP/SL Lines", group=groupDashboard)

// ─────────────────────────────────────────────────────────────────────────────
// WEBHOOK / ALERTS
// ─────────────────────────────────────────────────────────────────────────────
groupWebhook = "WEBHOOK / ALERTS"
enableWebhookAlerts = input.bool(false, "Enable Webhook Alerts", tooltip="Enable alert conditions for webhook integration", group=groupWebhook)

// Ready State inputs (connect to RZ Zone 3 levels from LuxAlgo)
extLongReadySignal = input.source(close, "Long Ready Signal", tooltip="Connect to 'Long Ready' plot from LuxAlgo (1 when oversold)", group=groupWebhook)
extShortReadySignal = input.source(close, "Short Ready Signal", tooltip="Connect to 'Short Ready' plot from LuxAlgo (1 when overbought)", group=groupWebhook)

// Zone levels for ML data
extRZS1 = input.source(close, "RZ S1 (Support 1)", tooltip="Connect to RZ S1 level", group=groupWebhook)
extRZS2 = input.source(close, "RZ S2 (Support 2)", tooltip="Connect to RZ S2 level", group=groupWebhook)
extRZS3 = input.source(close, "RZ S3 (Support 3)", tooltip="Connect to RZ S3 level", group=groupWebhook)
extRZR1 = input.source(close, "RZ R1 (Resistance 1)", tooltip="Connect to RZ R1 level", group=groupWebhook)
extRZR2 = input.source(close, "RZ R2 (Resistance 2)", tooltip="Connect to RZ R2 level", group=groupWebhook)
extRZR3 = input.source(close, "RZ R3 (Resistance 3)", tooltip="Connect to RZ R3 level", group=groupWebhook)

// ML Feature inputs (optional)
extRSI = input.source(close, "RSI Source", tooltip="Connect to RSI for ML data", group=groupWebhook)
extVolume = input.source(close, "Volume Ratio Source", tooltip="Connect to volume ratio indicator", group=groupWebhook)

// =============================================================================
// CALCULATIONS
// =============================================================================

// ATR Calculation
atr = ta.atr(atrLength)

// Get Entry Price for Long trades
getLongEntryPrice() =>
    switch entryPriceSource
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        "HL2" => hl2
        "HLC3" => hlc3
        "OHLC4" => ohlc4
        "Custom Source" => extLongEntryPrice
        => close

// Get Entry Price for Short trades
getShortEntryPrice() =>
    switch entryPriceSource
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        "HL2" => hl2
        "HLC3" => hlc3
        "OHLC4" => ohlc4
        "Custom Source" => extShortEntryPrice
        => close

// Calculate TP distance
getTPDistance() =>
    switch tpType
        "ATR" => atr * tpAtrMult
        "Percent" => close * (tpPercent / 100)
        "Fixed Points" => tpPoints * syminfo.mintick
        "Custom Source" => math.abs(extTpSource - close)
        => atr * tpAtrMult

// Calculate SL distance
getSLDistance() =>
    switch slType
        "ATR" => atr * slAtrMult
        "Percent" => close * (slPercent / 100)
        "Fixed Points" => slPoints * syminfo.mintick
        "Custom Source" => math.abs(extSlSource - close)
        => atr * slAtrMult

// Signal Detection (respects Enable Long/Short settings)
longSignal = enableLong and (signalSource == "External" ? ta.crossover(extLongSignal, extLongThreshold) : false)
shortSignal = enableShort and (signalSource == "External" ? ta.crossover(extShortSignal, extShortThreshold) : false)

// =============================================================================
// READY STATE TRACKING (for Webhook System)
// =============================================================================

// Ready state detection (when in Zone 3 = oversold/overbought)
longReady = extLongReadySignal > 0.5   // In oversold zone
shortReady = extShortReadySignal > 0.5  // In overbought zone

// Track ready state changes
var bool wasLongReady = false
var bool wasShortReady = false
var int longReadyBar = na
var int shortReadyBar = na
var int barsInLongReady = 0
var int barsInShortReady = 0

// Long ready state tracking
if longReady and not wasLongReady
    longReadyBar := bar_index
    barsInLongReady := 0
if longReady
    barsInLongReady += 1
if not longReady
    barsInLongReady := 0
wasLongReady := longReady

// Short ready state tracking
if shortReady and not wasShortReady
    shortReadyBar := bar_index
    barsInShortReady := 0
if shortReady
    barsInShortReady += 1
if not shortReady
    barsInShortReady := 0
wasShortReady := shortReady

// Calculate projected TP/SL for ready states (before trade triggers)
projectedLongEntry = getLongEntryPrice()
projectedShortEntry = getShortEntryPrice()
projectedLongTP = projectedLongEntry + getTPDistance()
projectedLongSL = projectedLongEntry - getSLDistance()
projectedShortTP = projectedShortEntry - getTPDistance()
projectedShortSL = projectedShortEntry + getSLDistance()

// Zone width calculations (for ML)
longZoneWidth = math.abs(extRZS1 - extRZS3)
shortZoneWidth = math.abs(extRZR1 - extRZR3)
distanceToLongEntry = math.abs(close - projectedLongEntry)
distanceToShortEntry = math.abs(close - projectedShortEntry)

// =============================================================================
// TRADE TRACKING
// =============================================================================

// Trade State Variables
var bool inLongTrade = false
var bool inShortTrade = false
var float entryPrice = na
var float tpPrice = na
var float slPrice = na
var int entryBar = na
var int tradeDirection = 0  // 1 = long, -1 = short

// Statistics Variables
var int totalTrades = 0
var int winningTrades = 0
var int losingTrades = 0
var float totalProfitPercent = 0.0
var float totalProfitAmount = 0.0
var float currentCapital = initialCapital
var float maxCapital = initialCapital
var float maxDrawdown = 0.0
var float grossProfit = 0.0
var float grossLoss = 0.0
var float largestWin = 0.0
var float largestLoss = 0.0
var int consecutiveWins = 0
var int consecutiveLosses = 0
var int maxConsecutiveWins = 0
var int maxConsecutiveLosses = 0
var int currentStreak = 0

// Position Size Calculation with Leverage and Risk Management
// slDistancePercent = how far SL is from entry in percent (e.g., 0.65 for 0.65%)
getPositionSize(slDistancePercent) =>
    // Base equity (compounding or not)
    equity = useCompounding ? currentCapital : initialCapital

    // Calculate base position size
    float basePosition = 0.0
    if positionSizing == "Percent"
        basePosition := equity * (positionPercent / 100)
    else if positionSizing == "Fixed"
        basePosition := fixedPositionSize
    else  // Risk-Based: position sized so that SL = maxRiskPercent loss
        // Position = (Equity × MaxRisk%) / (SL% × Leverage)
        if slDistancePercent > 0
            basePosition := (equity * (maxRiskPercent / 100)) / (slDistancePercent / 100 * leverage)
        else
            basePosition := equity * (positionPercent / 100)

    // Apply Max Risk Cap if enabled (for Percent and Fixed modes)
    float finalPosition = basePosition
    if useMaxRiskCap and positionSizing != "Risk-Based" and slDistancePercent > 0
        // Calculate what the loss would be with base position
        // Loss = Position × SL% × Leverage
        potentialLoss = basePosition * (slDistancePercent / 100) * leverage
        maxAllowedLoss = equity * (maxRiskPercent / 100)

        // If potential loss exceeds max allowed, reduce position
        if potentialLoss > maxAllowedLoss
            // Solve for position: maxAllowedLoss = Position × SL% × Leverage
            // Position = maxAllowedLoss / (SL% × Leverage)
            finalPosition := maxAllowedLoss / (slDistancePercent / 100 * leverage)

    finalPosition

// Fee Calculation
calculateFees(tradeValue) =>
    if not useFees
        0.0
    else if feeType == "Percent"
        tradeValue * ((entryFee + exitFee) / 100)
    else
        fixedFeePerTrade

// Check if TP or SL hit using Lower Timeframe
checkTPSLHit(isLong, tp, sl, isSignalBar) =>
    tpHit = false
    slHit = false

    if isLong
        tpHit := high >= tp
        slHit := low <= sl
    else
        tpHit := low <= tp
        slHit := high >= sl

    // Determine which was hit first
    result = 0  // 0 = none, 1 = TP, -1 = SL

    if tpHit and slHit
        // Both hit - use different logic for signal bar vs next bars
        conflictResolution = isSignalBar ? signalBarMode : nextBarMode

        // TODO: Implement lower TF check with request.security for more accuracy
        // For now, use conflict resolution modes
        if conflictResolution == "TP First" or conflictResolution == "Optimistic"
            result := 1   // TP first (signal bar = good direction)
        else if conflictResolution == "Pessimistic"
            result := -1  // SL first (worse case)
        else  // Open-Based
            if isLong
                result := open > (tp + sl) / 2 ? -1 : 1
            else
                result := open < (tp + sl) / 2 ? -1 : 1
    else if tpHit
        result := 1
    else if slHit
        result := -1

    result

// =============================================================================
// TRADE EXECUTION LOGIC
// =============================================================================

// Additional trade tracking variables
var float tradePositionSize = na
var float tradeSLDistancePercent = na

// Entry Logic
if longSignal and not inLongTrade and (allowPyramiding or not inShortTrade)
    if inShortTrade
        // Close short first (simplified - would need proper exit handling)
        inShortTrade := false

    inLongTrade := true
    entryPrice := getLongEntryPrice()
    tpPrice := entryPrice + getTPDistance()
    slPrice := entryPrice - getSLDistance()
    entryBar := bar_index
    tradeDirection := 1

    // Calculate SL distance in percent and position size
    tradeSLDistancePercent := math.abs(entryPrice - slPrice) / entryPrice * 100
    tradePositionSize := getPositionSize(tradeSLDistancePercent)

if shortSignal and not inShortTrade and (allowPyramiding or not inLongTrade)
    if inLongTrade
        inLongTrade := false

    inShortTrade := true
    entryPrice := getShortEntryPrice()
    tpPrice := entryPrice - getTPDistance()
    slPrice := entryPrice + getSLDistance()
    entryBar := bar_index
    tradeDirection := -1

    // Calculate SL distance in percent and position size
    tradeSLDistancePercent := math.abs(slPrice - entryPrice) / entryPrice * 100
    tradePositionSize := getPositionSize(tradeSLDistancePercent)

// Variables for exit visualization
var bool longExitTP = false
var bool longExitSL = false
var bool shortExitTP = false
var bool shortExitSL = false
var float exitPriceViz = na
longExitTP := false
longExitSL := false
shortExitTP := false
shortExitSL := false

// Exit Logic - Check TP/SL
if inLongTrade and bar_index >= entryBar
    isSignalBar = bar_index == entryBar
    exitResult = checkTPSLHit(true, tpPrice, slPrice, isSignalBar)

    if exitResult != 0
        posSize = tradePositionSize

        float exitPrice = exitResult == 1 ? tpPrice : slPrice
        // PnL with leverage: price move % × leverage × position
        float priceChangePercent = ((exitPrice - entryPrice) / entryPrice) * 100
        float pnlPercent = priceChangePercent * leverage
        float pnlAmount = posSize * (pnlPercent / 100)
        float fees = calculateFees(posSize)

        pnlAmount := pnlAmount - fees
        pnlPercent := (pnlAmount / posSize) * 100

        totalTrades += 1
        totalProfitPercent += pnlPercent
        totalProfitAmount += pnlAmount
        currentCapital += pnlAmount

        // Track exit for visualization
        exitPriceViz := exitPrice
        if exitResult == 1
            longExitTP := true
        else
            longExitSL := true

        if pnlAmount > 0
            winningTrades += 1
            grossProfit += pnlAmount
            largestWin := math.max(largestWin, pnlAmount)
            if currentStreak >= 0
                currentStreak += 1
            else
                currentStreak := 1
            consecutiveWins := currentStreak
            maxConsecutiveWins := math.max(maxConsecutiveWins, consecutiveWins)
        else
            losingTrades += 1
            grossLoss += math.abs(pnlAmount)
            largestLoss := math.max(largestLoss, math.abs(pnlAmount))
            if currentStreak <= 0
                currentStreak -= 1
            else
                currentStreak := -1
            consecutiveLosses := math.abs(currentStreak)
            maxConsecutiveLosses := math.max(maxConsecutiveLosses, consecutiveLosses)

        maxCapital := math.max(maxCapital, currentCapital)
        drawdown = ((maxCapital - currentCapital) / maxCapital) * 100
        maxDrawdown := math.max(maxDrawdown, drawdown)

        inLongTrade := false
        entryPrice := na
        tpPrice := na
        slPrice := na
        tradePositionSize := na

if inShortTrade and bar_index >= entryBar
    isSignalBar = bar_index == entryBar
    exitResult = checkTPSLHit(false, tpPrice, slPrice, isSignalBar)

    if exitResult != 0
        posSize = tradePositionSize

        float exitPrice = exitResult == 1 ? tpPrice : slPrice
        // PnL with leverage: price move % × leverage × position
        float priceChangePercent = ((entryPrice - exitPrice) / entryPrice) * 100
        float pnlPercent = priceChangePercent * leverage
        float pnlAmount = posSize * (pnlPercent / 100)
        float fees = calculateFees(posSize)

        pnlAmount := pnlAmount - fees
        pnlPercent := (pnlAmount / posSize) * 100

        totalTrades += 1
        totalProfitPercent += pnlPercent
        totalProfitAmount += pnlAmount
        currentCapital += pnlAmount

        // Track exit for visualization
        exitPriceViz := exitPrice
        if exitResult == 1
            shortExitTP := true
        else
            shortExitSL := true

        if pnlAmount > 0
            winningTrades += 1
            grossProfit += pnlAmount
            largestWin := math.max(largestWin, pnlAmount)
            if currentStreak >= 0
                currentStreak += 1
            else
                currentStreak := 1
            consecutiveWins := currentStreak
            maxConsecutiveWins := math.max(maxConsecutiveWins, consecutiveWins)
        else
            losingTrades += 1
            grossLoss += math.abs(pnlAmount)
            largestLoss := math.max(largestLoss, math.abs(pnlAmount))
            if currentStreak <= 0
                currentStreak -= 1
            else
                currentStreak := -1
            consecutiveLosses := math.abs(currentStreak)
            maxConsecutiveLosses := math.max(maxConsecutiveLosses, consecutiveLosses)

        maxCapital := math.max(maxCapital, currentCapital)
        drawdown = ((maxCapital - currentCapital) / maxCapital) * 100
        maxDrawdown := math.max(maxDrawdown, drawdown)

        inShortTrade := false
        entryPrice := na
        tpPrice := na
        slPrice := na
        tradePositionSize := na

// =============================================================================
// VISUALIZATION
// =============================================================================

// Variables for tracking trade visualization
var float lastEntryPrice = na
var float lastTpPrice = na
var float lastSlPrice = na
var float lastExitPrice = na
var int lastEntryBar = na
var int lastExitBar = na
var int lastTradeDir = 0
var bool lastTradeWin = false

// Plot TP/SL Lines for current trade
plot(showTPSLLines and inLongTrade ? tpPrice : na, "Long TP", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inLongTrade ? slPrice : na, "Long SL", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inLongTrade ? entryPrice : na, "Long Entry", color=color.new(color.blue, 0), style=plot.style_linebr, linewidth=2)

plot(showTPSLLines and inShortTrade ? tpPrice : na, "Short TP", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inShortTrade ? slPrice : na, "Short SL", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inShortTrade ? entryPrice : na, "Short Entry", color=color.new(color.blue, 0), style=plot.style_linebr, linewidth=2)

// Trade Entry Markers with Labels
if showTradesOnChart and longSignal and not inLongTrade[1]
    label.new(bar_index, low, "LONG\n" + str.tostring(getLongEntryPrice(), "#.###"), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)

if showTradesOnChart and shortSignal and not inShortTrade[1]
    label.new(bar_index, high, "SHORT\n" + str.tostring(getShortEntryPrice(), "#.###"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// Trade Exit Markers - Show WIN (TP hit) or LOSS (SL hit)
if showTradesOnChart and longExitTP
    label.new(bar_index, high, "WIN ✓\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_down, color=color.new(#00c853, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and longExitSL
    label.new(bar_index, high, "LOSS ✗\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_down, color=color.new(#ff1744, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and shortExitTP
    label.new(bar_index, low, "WIN ✓\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_up, color=color.new(#00c853, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and shortExitSL
    label.new(bar_index, low, "LOSS ✗\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_up, color=color.new(#ff1744, 0), textcolor=color.white, size=size.small)

// =============================================================================
// DASHBOARD
// =============================================================================

if showDashboard and barstate.islast
    // Dashboard positioning
    tablePos = switch dashboardPosition
        "Top Right" => position.top_right
        "Top Left" => position.top_left
        "Bottom Right" => position.bottom_right
        "Bottom Left" => position.bottom_left
        => position.top_right

    tableSize = switch dashboardSize
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        => size.normal

    // Calculate statistics
    winrate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0.0
    avgWin = winningTrades > 0 ? grossProfit / winningTrades : 0.0
    avgLoss = losingTrades > 0 ? grossLoss / losingTrades : 0.0
    profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999.99 : 0.0
    returnPercent = ((currentCapital - initialCapital) / initialCapital) * 100
    expectancy = totalTrades > 0 ? totalProfitAmount / totalTrades : 0.0

    // Colors
    profitColor = totalProfitAmount >= 0 ? color.green : color.red
    winrateColor = winrate >= 50 ? color.green : color.orange
    drawdownColor = maxDrawdown < 10 ? color.green : maxDrawdown < 20 ? color.orange : color.red

    // Create table
    var table dashboard = table.new(tablePos, 2, 14, bgcolor=color.new(#1e222d, 10), border_color=color.new(#373a46, 0), border_width=1)

    // Header
    table.cell(dashboard, 0, 0, "BACKTESTER", text_color=color.white, text_size=tableSize, bgcolor=color.new(#2962ff, 20))
    table.cell(dashboard, 1, 0, "STATS", text_color=color.white, text_size=tableSize, bgcolor=color.new(#2962ff, 20))

    // Stats rows
    table.cell(dashboard, 0, 1, "Total Trades", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 1, str.tostring(totalTrades), text_color=color.white, text_size=tableSize)

    table.cell(dashboard, 0, 2, "Win Rate", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 2, str.tostring(winrate, "#.##") + "%", text_color=winrateColor, text_size=tableSize)

    table.cell(dashboard, 0, 3, "Wins / Losses", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 3, str.tostring(winningTrades) + " / " + str.tostring(losingTrades), text_color=color.white, text_size=tableSize)

    table.cell(dashboard, 0, 4, "Net Profit", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 4, str.tostring(totalProfitAmount, "#.##"), text_color=profitColor, text_size=tableSize)

    table.cell(dashboard, 0, 5, "Return %", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 5, str.tostring(returnPercent, "#.##") + "%", text_color=profitColor, text_size=tableSize)

    table.cell(dashboard, 0, 6, "Profit Factor", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 6, str.tostring(profitFactor, "#.##"), text_color=profitFactor >= 1 ? color.green : color.red, text_size=tableSize)

    table.cell(dashboard, 0, 7, "Max Drawdown", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 7, str.tostring(maxDrawdown, "#.##") + "%", text_color=drawdownColor, text_size=tableSize)

    table.cell(dashboard, 0, 8, "Avg Win", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 8, str.tostring(avgWin, "#.##"), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 9, "Avg Loss", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 9, str.tostring(avgLoss, "#.##"), text_color=color.red, text_size=tableSize)

    table.cell(dashboard, 0, 10, "Largest Win", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 10, str.tostring(largestWin, "#.##"), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 11, "Largest Loss", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 11, str.tostring(largestLoss, "#.##"), text_color=color.red, text_size=tableSize)

    table.cell(dashboard, 0, 12, "Max Consec. Wins", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 12, str.tostring(maxConsecutiveWins), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 13, "Max Consec. Losses", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 13, str.tostring(maxConsecutiveLosses), text_color=color.red, text_size=tableSize)

// =============================================================================
// EXPORT PLOTS (for connecting to other indicators)
// =============================================================================
// These can be used by other indicators to read the backtester state
plot(inLongTrade ? 1 : 0, "In Long Trade", display=display.none)
plot(inShortTrade ? 1 : 0, "In Short Trade", display=display.none)
plot(entryPrice, "Current Entry Price", display=display.none)
plot(tpPrice, "Current TP Price", display=display.none)
plot(slPrice, "Current SL Price", display=display.none)

// =============================================================================
// WEBHOOK EXPORT PLOTS (for Railway/Supabase integration)
// =============================================================================
// Ready State
plot(longReady ? 1 : 0, "Long Ready State", display=display.none)
plot(shortReady ? 1 : 0, "Short Ready State", display=display.none)

// Projected Entry/TP/SL (updated every bar while ready)
plot(projectedLongEntry, "Projected Long Entry", display=display.none)
plot(projectedLongTP, "Projected Long TP", display=display.none)
plot(projectedLongSL, "Projected Long SL", display=display.none)
plot(projectedShortEntry, "Projected Short Entry", display=display.none)
plot(projectedShortTP, "Projected Short TP", display=display.none)
plot(projectedShortSL, "Projected Short SL", display=display.none)

// ML Feature Exports
plot(atr, "ATR Value", display=display.none)
plot(longZoneWidth, "Long Zone Width (S1-S3)", display=display.none)
plot(shortZoneWidth, "Short Zone Width (R1-R3)", display=display.none)
plot(barsInLongReady, "Bars in Long Ready", display=display.none)
plot(barsInShortReady, "Bars in Short Ready", display=display.none)
plot(distanceToLongEntry, "Distance to Long Entry", display=display.none)
plot(distanceToShortEntry, "Distance to Short Entry", display=display.none)

// Trade outcome for ML (1 = win, -1 = loss, 0 = no exit)
tradeOutcome = longExitTP or shortExitTP ? 1 : longExitSL or shortExitSL ? -1 : 0
plot(tradeOutcome, "Trade Outcome", display=display.none)

// =============================================================================
// ALERT CONDITIONS
// =============================================================================
// Ready state alerts (first entry into zone)
longReadyNew = longReady and not wasLongReady[1]
shortReadyNew = shortReady and not wasShortReady[1]

// Exit ready state (left zone without triggering)
longReadyCancelled = not longReady and wasLongReady[1] and not longSignal
shortReadyCancelled = not shortReady and wasShortReady[1] and not shortSignal

// Trigger alerts (actual entry)
longTriggered = longSignal
shortTriggered = shortSignal

// Exit alerts
longExitAlert = longExitTP or longExitSL
shortExitAlert = shortExitTP or shortExitSL

// Alert conditions (only fire when webhook alerts enabled)
alertcondition(enableWebhookAlerts and longReadyNew, title="READY_LONG", message='{"type":"READY","direction":"LONG","coin":"{{ticker}}","entry":{{plot("Projected Long Entry")}},"tp":{{plot("Projected Long TP")}},"sl":{{plot("Projected Long SL")}},"atr":{{plot("ATR Value")}},"zoneWidth":{{plot("Long Zone Width (S1-S3)")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortReadyNew, title="READY_SHORT", message='{"type":"READY","direction":"SHORT","coin":"{{ticker}}","entry":{{plot("Projected Short Entry")}},"tp":{{plot("Projected Short TP")}},"sl":{{plot("Projected Short SL")}},"atr":{{plot("ATR Value")}},"zoneWidth":{{plot("Short Zone Width (R1-R3)")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longReady, title="UPDATE_LONG", message='{"type":"UPDATE","direction":"LONG","coin":"{{ticker}}","entry":{{plot("Projected Long Entry")}},"tp":{{plot("Projected Long TP")}},"sl":{{plot("Projected Long SL")}},"barsReady":{{plot("Bars in Long Ready")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortReady, title="UPDATE_SHORT", message='{"type":"UPDATE","direction":"SHORT","coin":"{{ticker}}","entry":{{plot("Projected Short Entry")}},"tp":{{plot("Projected Short TP")}},"sl":{{plot("Projected Short SL")}},"barsReady":{{plot("Bars in Short Ready")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longTriggered, title="TRIGGERED_LONG", message='{"type":"TRIGGERED","direction":"LONG","coin":"{{ticker}}","entry":{{plot("Current Entry Price")}},"tp":{{plot("Current TP Price")}},"sl":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortTriggered, title="TRIGGERED_SHORT", message='{"type":"TRIGGERED","direction":"SHORT","coin":"{{ticker}}","entry":{{plot("Current Entry Price")}},"tp":{{plot("Current TP Price")}},"sl":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longExitTP, title="EXIT_LONG_WIN", message='{"type":"EXIT","direction":"LONG","outcome":"WIN","coin":"{{ticker}}","exitPrice":{{plot("Current TP Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longExitSL, title="EXIT_LONG_LOSS", message='{"type":"EXIT","direction":"LONG","outcome":"LOSS","coin":"{{ticker}}","exitPrice":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortExitTP, title="EXIT_SHORT_WIN", message='{"type":"EXIT","direction":"SHORT","outcome":"WIN","coin":"{{ticker}}","exitPrice":{{plot("Current TP Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortExitSL, title="EXIT_SHORT_LOSS", message='{"type":"EXIT","direction":"SHORT","outcome":"LOSS","coin":"{{ticker}}","exitPrice":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longReadyCancelled, title="CANCELLED_LONG", message='{"type":"CANCELLED","direction":"LONG","coin":"{{ticker}}","time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortReadyCancelled, title="CANCELLED_SHORT", message='{"type":"CANCELLED","direction":"SHORT","coin":"{{ticker}}","time":"{{time}}"}')
