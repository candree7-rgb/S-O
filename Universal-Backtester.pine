//@version=6
indicator("Universal Backtester", overlay=true, max_labels_count=500, max_boxes_count=500)

// =============================================================================
// SETTINGS
// =============================================================================

// ─────────────────────────────────────────────────────────────────────────────
// SIGNAL SOURCE
// ─────────────────────────────────────────────────────────────────────────────
groupSignal = "SIGNAL SOURCE"
signalSource = input.string("Multi-Step", "Signal Source", options=["External", "Multi-Step"], tooltip="External: Simple crossover signal\nMulti-Step: LuxAlgo-style step conditions", group=groupSignal)
enableLong = input.bool(true, "Enable Long Trades", tooltip="Allow Long/Buy trades", group=groupSignal)
enableShort = input.bool(true, "Enable Short Trades", tooltip="Allow Short/Sell trades", group=groupSignal)

// External signal inputs (for "External" mode)
extLongSignal = input.source(close, "Long Signal Source", tooltip="Connect to indicator's Long/Buy signal plot (1 = signal, 0 = no signal)", group=groupSignal)
extShortSignal = input.source(close, "Short Signal Source", tooltip="Connect to indicator's Short/Sell signal plot (1 = signal, 0 = no signal)", group=groupSignal)
extLongThreshold = input.float(0.5, "Long Signal Threshold", tooltip="Signal triggers when source crosses above this value", group=groupSignal)
extShortThreshold = input.float(0.5, "Short Signal Threshold", tooltip="Signal triggers when source crosses above this value", group=groupSignal)

// Entry price source
entryPriceSource = input.string("Custom Source", "Entry Price Type", options=["Close", "Open", "High", "Low", "HL2", "HLC3", "OHLC4", "Custom Source"], tooltip="Price used for entry", group=groupSignal)
extLongEntryPrice = input.source(close, "Long Entry Price Source", tooltip="Connect to RZ S1 (Support) for Long entries", group=groupSignal)
extShortEntryPrice = input.source(close, "Short Entry Price Source", tooltip="Connect to RZ R1 (Resistance) for Short entries", group=groupSignal)

// ─────────────────────────────────────────────────────────────────────────────
// LONG CONDITIONS (Multi-Step)
// ─────────────────────────────────────────────────────────────────────────────
groupLongSteps = "LONG CONDITIONS"

// Condition 1 (e.g., Low crossing under S3 = READY)
longC1Enable = input.bool(true, "─── Condition 1 ───", group=groupLongSteps)
longC1Price = input.string("Low", "  Price", options=["Close", "Open", "High", "Low"], group=groupLongSteps)
longC1Condition = input.string("Crossing Under", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupLongSteps)
longC1Level = input.source(close, "  Level", tooltip="Connect to RZ S3", group=groupLongSteps)
longC1Step = input.int(1, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupLongSteps)

// Condition 2 (e.g., High crossing over S1 = TRIGGERED)
longC2Enable = input.bool(true, "─── Condition 2 ───", group=groupLongSteps)
longC2Price = input.string("High", "  Price", options=["Close", "Open", "High", "Low"], group=groupLongSteps)
longC2Condition = input.string("Crossing Over", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupLongSteps)
longC2Level = input.source(close, "  Level", tooltip="Connect to RZ S1", group=groupLongSteps)
longC2Step = input.int(2, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupLongSteps)

// Condition 3 (optional, e.g., RSI < 30)
longC3Enable = input.bool(false, "─── Condition 3 ───", group=groupLongSteps)
longC3Price = input.string("Close", "  Price", options=["Close", "Open", "High", "Low"], group=groupLongSteps)
longC3Condition = input.string("Less Than", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupLongSteps)
longC3Level = input.source(close, "  Level", tooltip="Optional condition", group=groupLongSteps)
longC3Step = input.int(1, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupLongSteps)

// Condition 4 (optional)
longC4Enable = input.bool(false, "─── Condition 4 ───", group=groupLongSteps)
longC4Price = input.string("Close", "  Price", options=["Close", "Open", "High", "Low"], group=groupLongSteps)
longC4Condition = input.string("Greater Than", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupLongSteps)
longC4Level = input.source(close, "  Level", tooltip="Optional condition", group=groupLongSteps)
longC4Step = input.int(2, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupLongSteps)

// Step settings
longMaxStepInterval = input.int(10, "Max Step Interval", minval=1, maxval=100, tooltip="Maximum bars between Step 1 and Step 2", group=groupLongSteps)

// ─────────────────────────────────────────────────────────────────────────────
// SHORT CONDITIONS (Multi-Step)
// ─────────────────────────────────────────────────────────────────────────────
groupShortSteps = "SHORT CONDITIONS"

// Condition 1 (e.g., High crossing over R3 = READY)
shortC1Enable = input.bool(true, "─── Condition 1 ───", group=groupShortSteps)
shortC1Price = input.string("High", "  Price", options=["Close", "Open", "High", "Low"], group=groupShortSteps)
shortC1Condition = input.string("Crossing Over", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupShortSteps)
shortC1Level = input.source(close, "  Level", tooltip="Connect to RZ R3", group=groupShortSteps)
shortC1Step = input.int(1, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupShortSteps)

// Condition 2 (e.g., Low crossing under R1 = TRIGGERED)
shortC2Enable = input.bool(true, "─── Condition 2 ───", group=groupShortSteps)
shortC2Price = input.string("Low", "  Price", options=["Close", "Open", "High", "Low"], group=groupShortSteps)
shortC2Condition = input.string("Crossing Under", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupShortSteps)
shortC2Level = input.source(close, "  Level", tooltip="Connect to RZ R1", group=groupShortSteps)
shortC2Step = input.int(2, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupShortSteps)

// Condition 3 (optional)
shortC3Enable = input.bool(false, "─── Condition 3 ───", group=groupShortSteps)
shortC3Price = input.string("Close", "  Price", options=["Close", "Open", "High", "Low"], group=groupShortSteps)
shortC3Condition = input.string("Greater Than", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupShortSteps)
shortC3Level = input.source(close, "  Level", tooltip="Optional condition", group=groupShortSteps)
shortC3Step = input.int(1, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupShortSteps)

// Condition 4 (optional)
shortC4Enable = input.bool(false, "─── Condition 4 ───", group=groupShortSteps)
shortC4Price = input.string("Close", "  Price", options=["Close", "Open", "High", "Low"], group=groupShortSteps)
shortC4Condition = input.string("Less Than", "  Condition", options=["Crossing Under", "Crossing Over", "Less Than", "Greater Than"], group=groupShortSteps)
shortC4Level = input.source(close, "  Level", tooltip="Optional condition", group=groupShortSteps)
shortC4Step = input.int(2, "  Step", minval=1, maxval=2, tooltip="1=READY, 2=TRIGGERED", group=groupShortSteps)

// Step settings
shortMaxStepInterval = input.int(10, "Max Step Interval", minval=1, maxval=100, tooltip="Maximum bars between Step 1 and Step 2", group=groupShortSteps)

// ─────────────────────────────────────────────────────────────────────────────
// TP/SL SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupTPSL = "TP / SL SETTINGS"
tpType = input.string("ATR", "TP Type", options=["ATR", "Percent", "Fixed Points", "Custom Source"], group=groupTPSL)
slType = input.string("ATR", "SL Type", options=["ATR", "Percent", "Fixed Points", "Custom Source"], group=groupTPSL)

// ATR Settings
atrLength = input.int(14, "ATR Length", minval=1, group=groupTPSL)
tpAtrMult = input.float(2.0, "TP ATR Multiplier", minval=0.1, step=0.1, tooltip="TP = Entry ± (ATR × Multiplier)", group=groupTPSL)
slAtrMult = input.float(1.0, "SL ATR Multiplier", minval=0.1, step=0.1, tooltip="SL = Entry ∓ (ATR × Multiplier)", group=groupTPSL)

// Percent Settings
tpPercent = input.float(2.0, "TP Percent %", minval=0.1, step=0.1, group=groupTPSL)
slPercent = input.float(1.0, "SL Percent %", minval=0.1, step=0.1, group=groupTPSL)

// Fixed Points Settings
tpPoints = input.float(100, "TP Points", minval=1, group=groupTPSL)
slPoints = input.float(50, "SL Points", minval=1, group=groupTPSL)

// Custom Source (connect to RZ levels etc)
extTpSource = input.source(close, "Custom TP Source", tooltip="Connect to TP level from indicator", group=groupTPSL)
extSlSource = input.source(close, "Custom SL Source", tooltip="Connect to SL level from indicator", group=groupTPSL)

// ─────────────────────────────────────────────────────────────────────────────
// ACCURACY SETTINGS (Lower Timeframe)
// ─────────────────────────────────────────────────────────────────────────────
groupAccuracy = "ACCURACY SETTINGS"
useLowerTF = input.bool(true, "Use Lower Timeframe Check", tooltip="Check lower timeframe to determine if TP or SL was hit first (more accurate but less history)", group=groupAccuracy)
lowerTF = input.string("5", "Lower Timeframe", options=["1", "3", "5", "15", "30", "60"], tooltip="Timeframe in minutes for accuracy check (5m recommended for 15m chart)", group=groupAccuracy)
signalBarMode = input.string("TP First", "Signal Bar Conflict", options=["TP First", "Pessimistic", "Open-Based"], tooltip="On SIGNAL candle when both TP+SL hit: TP First recommended (cross = good direction)", group=groupAccuracy)
nextBarMode = input.string("Pessimistic", "Next Bar Conflict", options=["Pessimistic", "Optimistic", "Open-Based"], tooltip="On candles AFTER signal when both TP+SL hit", group=groupAccuracy)

// ─────────────────────────────────────────────────────────────────────────────
// FEES SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupFees = "FEES SETTINGS"
useFees = input.bool(true, "Enable Fees", group=groupFees)
feeType = input.string("Percent", "Fee Type", options=["Percent", "Fixed"], group=groupFees)
entryFee = input.float(0.04, "Entry Fee %", minval=0, step=0.01, tooltip="Fee on entry (e.g. 0.04% for Binance maker)", group=groupFees)
exitFee = input.float(0.04, "Exit Fee %", minval=0, step=0.01, tooltip="Fee on exit (e.g. 0.04% for Binance maker)", group=groupFees)
fixedFeePerTrade = input.float(0, "Fixed Fee per Trade", minval=0, tooltip="Fixed fee amount per trade", group=groupFees)

// ─────────────────────────────────────────────────────────────────────────────
// POSITION SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupPosition = "POSITION SETTINGS"
initialCapital = input.float(10000, "Initial Capital", minval=100, group=groupPosition)
leverage = input.float(20, "Leverage", minval=1, maxval=125, step=1, tooltip="Trading leverage (e.g., 20x)", group=groupPosition)
useCompounding = input.bool(true, "Use Compounding", tooltip="Position size based on current equity (true) or initial capital (false)", group=groupPosition)
positionSizing = input.string("Percent", "Position Sizing", options=["Percent", "Fixed", "Risk-Based"], group=groupPosition)
positionPercent = input.float(5, "Position Size %", minval=0.1, maxval=100, step=0.1, tooltip="Percent of equity per trade (before risk adjustment)", group=groupPosition)
fixedPositionSize = input.float(1000, "Fixed Position Size", minval=1, group=groupPosition)
maxRiskPercent = input.float(2, "Max Risk per Trade %", minval=0.1, maxval=50, step=0.1, tooltip="Maximum equity loss per trade. Position size reduced if SL would exceed this.", group=groupPosition)
useMaxRiskCap = input.bool(true, "Enable Max Risk Cap", tooltip="Automatically reduce position if SL exceeds max risk", group=groupPosition)
allowPyramiding = input.bool(false, "Allow Pyramiding", tooltip="Allow multiple positions at once", group=groupPosition)

// ─────────────────────────────────────────────────────────────────────────────
// DASHBOARD SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupDashboard = "DASHBOARD"
showDashboard = input.bool(true, "Show Dashboard", group=groupDashboard)
dashboardPosition = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=groupDashboard)
dashboardSize = input.string("Normal", "Dashboard Size", options=["Tiny", "Small", "Normal", "Large"], group=groupDashboard)
showTradesOnChart = input.bool(true, "Show Trades on Chart", group=groupDashboard)
showTPSLLines = input.bool(true, "Show TP/SL Lines", group=groupDashboard)

// ─────────────────────────────────────────────────────────────────────────────
// WEBHOOK / ALERTS
// ─────────────────────────────────────────────────────────────────────────────
groupWebhook = "WEBHOOK / ALERTS"
enableWebhookAlerts = input.bool(false, "Enable Webhook Alerts", tooltip="Enable alerts for Railway/Supabase webhook integration", group=groupWebhook)

// ML Feature inputs (optional - for extra data in alerts)
extRSI = input.source(close, "RSI Source (ML)", tooltip="Connect to RSI for ML data export", group=groupWebhook)
extVolume = input.source(close, "Volume Ratio (ML)", tooltip="Connect to volume ratio for ML data", group=groupWebhook)

// =============================================================================
// CALCULATIONS
// =============================================================================

// ATR Calculation
atr = ta.atr(atrLength)

// Get Entry Price for Long trades
getLongEntryPrice() =>
    switch entryPriceSource
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        "HL2" => hl2
        "HLC3" => hlc3
        "OHLC4" => ohlc4
        "Custom Source" => extLongEntryPrice
        => close

// Get Entry Price for Short trades
getShortEntryPrice() =>
    switch entryPriceSource
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        "HL2" => hl2
        "HLC3" => hlc3
        "OHLC4" => ohlc4
        "Custom Source" => extShortEntryPrice
        => close

// Calculate TP distance
getTPDistance() =>
    switch tpType
        "ATR" => atr * tpAtrMult
        "Percent" => close * (tpPercent / 100)
        "Fixed Points" => tpPoints * syminfo.mintick
        "Custom Source" => math.abs(extTpSource - close)
        => atr * tpAtrMult

// Calculate SL distance
getSLDistance() =>
    switch slType
        "ATR" => atr * slAtrMult
        "Percent" => close * (slPercent / 100)
        "Fixed Points" => slPoints * syminfo.mintick
        "Custom Source" => math.abs(extSlSource - close)
        => atr * slAtrMult

// =============================================================================
// MULTI-STEP SIGNAL LOGIC
// =============================================================================

// Helper: Get price based on selection
getStepPrice(priceType) =>
    switch priceType
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        => close

// Helper: Check step condition
checkCondition(priceType, condition, level) =>
    price = getStepPrice(priceType)
    switch condition
        "Crossing Under" => ta.crossunder(price, level)
        "Crossing Over" => ta.crossover(price, level)
        "Less Than" => price < level
        "Greater Than" => price > level
        => false

// Check each Long condition
longC1Met = longC1Enable ? checkCondition(longC1Price, longC1Condition, longC1Level) : true
longC2Met = longC2Enable ? checkCondition(longC2Price, longC2Condition, longC2Level) : true
longC3Met = longC3Enable ? checkCondition(longC3Price, longC3Condition, longC3Level) : true
longC4Met = longC4Enable ? checkCondition(longC4Price, longC4Condition, longC4Level) : true

// Check each Short condition
shortC1Met = shortC1Enable ? checkCondition(shortC1Price, shortC1Condition, shortC1Level) : true
shortC2Met = shortC2Enable ? checkCondition(shortC2Price, shortC2Condition, shortC2Level) : true
shortC3Met = shortC3Enable ? checkCondition(shortC3Price, shortC3Condition, shortC3Level) : true
shortC4Met = shortC4Enable ? checkCondition(shortC4Price, shortC4Condition, shortC4Level) : true

// Long Step 1 conditions (READY) - each condition check
longC1Step1Ok = not longC1Enable or longC1Step != 1 or longC1Met
longC2Step1Ok = not longC2Enable or longC2Step != 1 or longC2Met
longC3Step1Ok = not longC3Enable or longC3Step != 1 or longC3Met
longC4Step1Ok = not longC4Enable or longC4Step != 1 or longC4Met
longStep1Conditions = longC1Step1Ok and longC2Step1Ok and longC3Step1Ok and longC4Step1Ok

// Long Step 1 must have at least one crossing condition
longC1IsCross1 = longC1Enable and longC1Step == 1 and (longC1Condition == "Crossing Under" or longC1Condition == "Crossing Over")
longC2IsCross1 = longC2Enable and longC2Step == 1 and (longC2Condition == "Crossing Under" or longC2Condition == "Crossing Over")
longC3IsCross1 = longC3Enable and longC3Step == 1 and (longC3Condition == "Crossing Under" or longC3Condition == "Crossing Over")
longC4IsCross1 = longC4Enable and longC4Step == 1 and (longC4Condition == "Crossing Under" or longC4Condition == "Crossing Over")
longHasStep1Cross = longC1IsCross1 or longC2IsCross1 or longC3IsCross1 or longC4IsCross1
longStep1AllMet = longStep1Conditions and longHasStep1Cross

// Long Step 2 conditions (TRIGGERED) - each condition check
longC1Step2Ok = not longC1Enable or longC1Step != 2 or longC1Met
longC2Step2Ok = not longC2Enable or longC2Step != 2 or longC2Met
longC3Step2Ok = not longC3Enable or longC3Step != 2 or longC3Met
longC4Step2Ok = not longC4Enable or longC4Step != 2 or longC4Met
longStep2Conditions = longC1Step2Ok and longC2Step2Ok and longC3Step2Ok and longC4Step2Ok

// Long Step 2 must have at least one crossing condition
longC1IsCross2 = longC1Enable and longC1Step == 2 and (longC1Condition == "Crossing Under" or longC1Condition == "Crossing Over")
longC2IsCross2 = longC2Enable and longC2Step == 2 and (longC2Condition == "Crossing Under" or longC2Condition == "Crossing Over")
longC3IsCross2 = longC3Enable and longC3Step == 2 and (longC3Condition == "Crossing Under" or longC3Condition == "Crossing Over")
longC4IsCross2 = longC4Enable and longC4Step == 2 and (longC4Condition == "Crossing Under" or longC4Condition == "Crossing Over")
longHasStep2Cross = longC1IsCross2 or longC2IsCross2 or longC3IsCross2 or longC4IsCross2
longStep2AllMet = longStep2Conditions and longHasStep2Cross

// Short Step 1 conditions (READY) - each condition check
shortC1Step1Ok = not shortC1Enable or shortC1Step != 1 or shortC1Met
shortC2Step1Ok = not shortC2Enable or shortC2Step != 1 or shortC2Met
shortC3Step1Ok = not shortC3Enable or shortC3Step != 1 or shortC3Met
shortC4Step1Ok = not shortC4Enable or shortC4Step != 1 or shortC4Met
shortStep1Conditions = shortC1Step1Ok and shortC2Step1Ok and shortC3Step1Ok and shortC4Step1Ok

// Short Step 1 must have at least one crossing condition
shortC1IsCross1 = shortC1Enable and shortC1Step == 1 and (shortC1Condition == "Crossing Under" or shortC1Condition == "Crossing Over")
shortC2IsCross1 = shortC2Enable and shortC2Step == 1 and (shortC2Condition == "Crossing Under" or shortC2Condition == "Crossing Over")
shortC3IsCross1 = shortC3Enable and shortC3Step == 1 and (shortC3Condition == "Crossing Under" or shortC3Condition == "Crossing Over")
shortC4IsCross1 = shortC4Enable and shortC4Step == 1 and (shortC4Condition == "Crossing Under" or shortC4Condition == "Crossing Over")
shortHasStep1Cross = shortC1IsCross1 or shortC2IsCross1 or shortC3IsCross1 or shortC4IsCross1
shortStep1AllMet = shortStep1Conditions and shortHasStep1Cross

// Short Step 2 conditions (TRIGGERED) - each condition check
shortC1Step2Ok = not shortC1Enable or shortC1Step != 2 or shortC1Met
shortC2Step2Ok = not shortC2Enable or shortC2Step != 2 or shortC2Met
shortC3Step2Ok = not shortC3Enable or shortC3Step != 2 or shortC3Met
shortC4Step2Ok = not shortC4Enable or shortC4Step != 2 or shortC4Met
shortStep2Conditions = shortC1Step2Ok and shortC2Step2Ok and shortC3Step2Ok and shortC4Step2Ok

// Short Step 2 must have at least one crossing condition
shortC1IsCross2 = shortC1Enable and shortC1Step == 2 and (shortC1Condition == "Crossing Under" or shortC1Condition == "Crossing Over")
shortC2IsCross2 = shortC2Enable and shortC2Step == 2 and (shortC2Condition == "Crossing Under" or shortC2Condition == "Crossing Over")
shortC3IsCross2 = shortC3Enable and shortC3Step == 2 and (shortC3Condition == "Crossing Under" or shortC3Condition == "Crossing Over")
shortC4IsCross2 = shortC4Enable and shortC4Step == 2 and (shortC4Condition == "Crossing Under" or shortC4Condition == "Crossing Over")
shortHasStep2Cross = shortC1IsCross2 or shortC2IsCross2 or shortC3IsCross2 or shortC4IsCross2
shortStep2AllMet = shortStep2Conditions and shortHasStep2Cross

// Multi-step state tracking
var bool longStep1Active = false      // Step 1 has been triggered (READY)
var int longStep1Bar = na             // Bar where Step 1 triggered
var bool shortStep1Active = false
var int shortStep1Bar = na

// Long Step State Machine
if longStep1AllMet and not longStep1Active
    longStep1Active := true
    longStep1Bar := bar_index

// Check if step interval expired
if longStep1Active and (bar_index - longStep1Bar) > longMaxStepInterval
    longStep1Active := false
    longStep1Bar := na

// Short Step State Machine
if shortStep1AllMet and not shortStep1Active
    shortStep1Active := true
    shortStep1Bar := bar_index

if shortStep1Active and (bar_index - shortStep1Bar) > shortMaxStepInterval
    shortStep1Active := false
    shortStep1Bar := na

// Signal Detection
var bool longSignal = false
var bool shortSignal = false

if signalSource == "External"
    longSignal := enableLong and ta.crossover(extLongSignal, extLongThreshold)
    shortSignal := enableShort and ta.crossover(extShortSignal, extShortThreshold)
else  // Multi-Step mode
    // Long signal: Step 1 active + Step 2 all conditions met
    longSignal := enableLong and longStep1Active and longStep2AllMet
    shortSignal := enableShort and shortStep1Active and shortStep2AllMet

    // Reset step state after signal
    if longSignal
        longStep1Active := false
        longStep1Bar := na
    if shortSignal
        shortStep1Active := false
        shortStep1Bar := na

// =============================================================================
// READY STATE TRACKING (for Webhook System)
// =============================================================================

// Ready state = Step 1 is active (waiting for Step 2)
longReady = longStep1Active
shortReady = shortStep1Active

// Track ready state changes
var bool wasLongReady = false
var bool wasShortReady = false
var int longReadyBar = na
var int shortReadyBar = na
var int barsInLongReady = 0
var int barsInShortReady = 0

// Long ready state tracking
if longReady and not wasLongReady
    longReadyBar := bar_index
    barsInLongReady := 0
if longReady
    barsInLongReady += 1
if not longReady
    barsInLongReady := 0
wasLongReady := longReady

// Short ready state tracking
if shortReady and not wasShortReady
    shortReadyBar := bar_index
    barsInShortReady := 0
if shortReady
    barsInShortReady += 1
if not shortReady
    barsInShortReady := 0
wasShortReady := shortReady

// Calculate projected TP/SL for ready states (before trade triggers)
projectedLongEntry = getLongEntryPrice()
projectedShortEntry = getShortEntryPrice()
projectedLongTP = projectedLongEntry + getTPDistance()
projectedLongSL = projectedLongEntry - getSLDistance()
projectedShortTP = projectedShortEntry - getTPDistance()
projectedShortSL = projectedShortEntry + getSLDistance()

// Zone width calculations (for ML) - uses condition levels
// Assumes C1 = Zone 3 (S3/R3), C2 = Zone 1 (S1/R1)
longZoneWidth = math.abs(longC2Level - longC1Level)
shortZoneWidth = math.abs(shortC2Level - shortC1Level)
distanceToLongEntry = math.abs(close - projectedLongEntry)
distanceToShortEntry = math.abs(close - projectedShortEntry)

// =============================================================================
// TRADE TRACKING
// =============================================================================

// Trade State Variables
var bool inLongTrade = false
var bool inShortTrade = false
var float entryPrice = na
var float tpPrice = na
var float slPrice = na
var int entryBar = na
var int tradeDirection = 0  // 1 = long, -1 = short

// Statistics Variables
var int totalTrades = 0
var int winningTrades = 0
var int losingTrades = 0
var float totalProfitPercent = 0.0
var float totalProfitAmount = 0.0
var float currentCapital = initialCapital
var float maxCapital = initialCapital
var float maxDrawdown = 0.0
var float grossProfit = 0.0
var float grossLoss = 0.0
var float largestWin = 0.0
var float largestLoss = 0.0
var int consecutiveWins = 0
var int consecutiveLosses = 0
var int maxConsecutiveWins = 0
var int maxConsecutiveLosses = 0
var int currentStreak = 0

// Position Size Calculation with Leverage and Risk Management
// slDistancePercent = how far SL is from entry in percent (e.g., 0.65 for 0.65%)
getPositionSize(slDistancePercent) =>
    // Base equity (compounding or not)
    equity = useCompounding ? currentCapital : initialCapital

    // Calculate base position size
    float basePosition = 0.0
    if positionSizing == "Percent"
        basePosition := equity * (positionPercent / 100)
    else if positionSizing == "Fixed"
        basePosition := fixedPositionSize
    else  // Risk-Based: position sized so that SL = maxRiskPercent loss
        // Position = (Equity × MaxRisk%) / (SL% × Leverage)
        if slDistancePercent > 0
            basePosition := (equity * (maxRiskPercent / 100)) / (slDistancePercent / 100 * leverage)
        else
            basePosition := equity * (positionPercent / 100)

    // Apply Max Risk Cap if enabled (for Percent and Fixed modes)
    float finalPosition = basePosition
    if useMaxRiskCap and positionSizing != "Risk-Based" and slDistancePercent > 0
        // Calculate what the loss would be with base position
        // Loss = Position × SL% × Leverage
        potentialLoss = basePosition * (slDistancePercent / 100) * leverage
        maxAllowedLoss = equity * (maxRiskPercent / 100)

        // If potential loss exceeds max allowed, reduce position
        if potentialLoss > maxAllowedLoss
            // Solve for position: maxAllowedLoss = Position × SL% × Leverage
            // Position = maxAllowedLoss / (SL% × Leverage)
            finalPosition := maxAllowedLoss / (slDistancePercent / 100 * leverage)

    finalPosition

// Fee Calculation
calculateFees(tradeValue) =>
    if not useFees
        0.0
    else if feeType == "Percent"
        tradeValue * ((entryFee + exitFee) / 100)
    else
        fixedFeePerTrade

// Check if TP or SL hit using Lower Timeframe
checkTPSLHit(isLong, tp, sl, isSignalBar) =>
    tpHit = false
    slHit = false

    if isLong
        tpHit := high >= tp
        slHit := low <= sl
    else
        tpHit := low <= tp
        slHit := high >= sl

    // Determine which was hit first
    result = 0  // 0 = none, 1 = TP, -1 = SL

    if tpHit and slHit
        // Both hit - use different logic for signal bar vs next bars
        conflictResolution = isSignalBar ? signalBarMode : nextBarMode

        // TODO: Implement lower TF check with request.security for more accuracy
        // For now, use conflict resolution modes
        if conflictResolution == "TP First" or conflictResolution == "Optimistic"
            result := 1   // TP first (signal bar = good direction)
        else if conflictResolution == "Pessimistic"
            result := -1  // SL first (worse case)
        else  // Open-Based
            if isLong
                result := open > (tp + sl) / 2 ? -1 : 1
            else
                result := open < (tp + sl) / 2 ? -1 : 1
    else if tpHit
        result := 1
    else if slHit
        result := -1

    result

// =============================================================================
// TRADE EXECUTION LOGIC
// =============================================================================

// Additional trade tracking variables
var float tradePositionSize = na
var float tradeSLDistancePercent = na

// Entry Logic
if longSignal and not inLongTrade and (allowPyramiding or not inShortTrade)
    if inShortTrade
        // Close short first (simplified - would need proper exit handling)
        inShortTrade := false

    inLongTrade := true
    entryPrice := getLongEntryPrice()
    tpPrice := entryPrice + getTPDistance()
    slPrice := entryPrice - getSLDistance()
    entryBar := bar_index
    tradeDirection := 1

    // Calculate SL distance in percent and position size
    tradeSLDistancePercent := math.abs(entryPrice - slPrice) / entryPrice * 100
    tradePositionSize := getPositionSize(tradeSLDistancePercent)

if shortSignal and not inShortTrade and (allowPyramiding or not inLongTrade)
    if inLongTrade
        inLongTrade := false

    inShortTrade := true
    entryPrice := getShortEntryPrice()
    tpPrice := entryPrice - getTPDistance()
    slPrice := entryPrice + getSLDistance()
    entryBar := bar_index
    tradeDirection := -1

    // Calculate SL distance in percent and position size
    tradeSLDistancePercent := math.abs(slPrice - entryPrice) / entryPrice * 100
    tradePositionSize := getPositionSize(tradeSLDistancePercent)

// Variables for exit visualization
var bool longExitTP = false
var bool longExitSL = false
var bool shortExitTP = false
var bool shortExitSL = false
var float exitPriceViz = na
longExitTP := false
longExitSL := false
shortExitTP := false
shortExitSL := false

// Exit Logic - Check TP/SL
if inLongTrade and bar_index >= entryBar
    isSignalBar = bar_index == entryBar
    exitResult = checkTPSLHit(true, tpPrice, slPrice, isSignalBar)

    if exitResult != 0
        posSize = tradePositionSize

        float exitPrice = exitResult == 1 ? tpPrice : slPrice
        // PnL with leverage: price move % × leverage × position
        float priceChangePercent = ((exitPrice - entryPrice) / entryPrice) * 100
        float pnlPercent = priceChangePercent * leverage
        float pnlAmount = posSize * (pnlPercent / 100)
        float fees = calculateFees(posSize)

        pnlAmount := pnlAmount - fees
        pnlPercent := (pnlAmount / posSize) * 100

        totalTrades += 1
        totalProfitPercent += pnlPercent
        totalProfitAmount += pnlAmount
        currentCapital += pnlAmount

        // Track exit for visualization
        exitPriceViz := exitPrice
        if exitResult == 1
            longExitTP := true
        else
            longExitSL := true

        if pnlAmount > 0
            winningTrades += 1
            grossProfit += pnlAmount
            largestWin := math.max(largestWin, pnlAmount)
            if currentStreak >= 0
                currentStreak += 1
            else
                currentStreak := 1
            consecutiveWins := currentStreak
            maxConsecutiveWins := math.max(maxConsecutiveWins, consecutiveWins)
        else
            losingTrades += 1
            grossLoss += math.abs(pnlAmount)
            largestLoss := math.max(largestLoss, math.abs(pnlAmount))
            if currentStreak <= 0
                currentStreak -= 1
            else
                currentStreak := -1
            consecutiveLosses := math.abs(currentStreak)
            maxConsecutiveLosses := math.max(maxConsecutiveLosses, consecutiveLosses)

        maxCapital := math.max(maxCapital, currentCapital)
        drawdown = ((maxCapital - currentCapital) / maxCapital) * 100
        maxDrawdown := math.max(maxDrawdown, drawdown)

        inLongTrade := false
        entryPrice := na
        tpPrice := na
        slPrice := na
        tradePositionSize := na

if inShortTrade and bar_index >= entryBar
    isSignalBar = bar_index == entryBar
    exitResult = checkTPSLHit(false, tpPrice, slPrice, isSignalBar)

    if exitResult != 0
        posSize = tradePositionSize

        float exitPrice = exitResult == 1 ? tpPrice : slPrice
        // PnL with leverage: price move % × leverage × position
        float priceChangePercent = ((entryPrice - exitPrice) / entryPrice) * 100
        float pnlPercent = priceChangePercent * leverage
        float pnlAmount = posSize * (pnlPercent / 100)
        float fees = calculateFees(posSize)

        pnlAmount := pnlAmount - fees
        pnlPercent := (pnlAmount / posSize) * 100

        totalTrades += 1
        totalProfitPercent += pnlPercent
        totalProfitAmount += pnlAmount
        currentCapital += pnlAmount

        // Track exit for visualization
        exitPriceViz := exitPrice
        if exitResult == 1
            shortExitTP := true
        else
            shortExitSL := true

        if pnlAmount > 0
            winningTrades += 1
            grossProfit += pnlAmount
            largestWin := math.max(largestWin, pnlAmount)
            if currentStreak >= 0
                currentStreak += 1
            else
                currentStreak := 1
            consecutiveWins := currentStreak
            maxConsecutiveWins := math.max(maxConsecutiveWins, consecutiveWins)
        else
            losingTrades += 1
            grossLoss += math.abs(pnlAmount)
            largestLoss := math.max(largestLoss, math.abs(pnlAmount))
            if currentStreak <= 0
                currentStreak -= 1
            else
                currentStreak := -1
            consecutiveLosses := math.abs(currentStreak)
            maxConsecutiveLosses := math.max(maxConsecutiveLosses, consecutiveLosses)

        maxCapital := math.max(maxCapital, currentCapital)
        drawdown = ((maxCapital - currentCapital) / maxCapital) * 100
        maxDrawdown := math.max(maxDrawdown, drawdown)

        inShortTrade := false
        entryPrice := na
        tpPrice := na
        slPrice := na
        tradePositionSize := na

// =============================================================================
// VISUALIZATION
// =============================================================================

// Variables for tracking trade visualization
var float lastEntryPrice = na
var float lastTpPrice = na
var float lastSlPrice = na
var float lastExitPrice = na
var int lastEntryBar = na
var int lastExitBar = na
var int lastTradeDir = 0
var bool lastTradeWin = false

// Plot TP/SL Lines for current trade
plot(showTPSLLines and inLongTrade ? tpPrice : na, "Long TP", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inLongTrade ? slPrice : na, "Long SL", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inLongTrade ? entryPrice : na, "Long Entry", color=color.new(color.blue, 0), style=plot.style_linebr, linewidth=2)

plot(showTPSLLines and inShortTrade ? tpPrice : na, "Short TP", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inShortTrade ? slPrice : na, "Short SL", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inShortTrade ? entryPrice : na, "Short Entry", color=color.new(color.blue, 0), style=plot.style_linebr, linewidth=2)

// Trade Entry Markers with Labels
if showTradesOnChart and longSignal and not inLongTrade[1]
    label.new(bar_index, low, "LONG\n" + str.tostring(getLongEntryPrice(), "#.###"), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)

if showTradesOnChart and shortSignal and not inShortTrade[1]
    label.new(bar_index, high, "SHORT\n" + str.tostring(getShortEntryPrice(), "#.###"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// Trade Exit Markers - Show WIN (TP hit) or LOSS (SL hit)
if showTradesOnChart and longExitTP
    label.new(bar_index, high, "WIN ✓\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_down, color=color.new(#00c853, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and longExitSL
    label.new(bar_index, high, "LOSS ✗\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_down, color=color.new(#ff1744, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and shortExitTP
    label.new(bar_index, low, "WIN ✓\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_up, color=color.new(#00c853, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and shortExitSL
    label.new(bar_index, low, "LOSS ✗\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_up, color=color.new(#ff1744, 0), textcolor=color.white, size=size.small)

// =============================================================================
// DASHBOARD
// =============================================================================

if showDashboard and barstate.islast
    // Dashboard positioning
    tablePos = switch dashboardPosition
        "Top Right" => position.top_right
        "Top Left" => position.top_left
        "Bottom Right" => position.bottom_right
        "Bottom Left" => position.bottom_left
        => position.top_right

    tableSize = switch dashboardSize
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        => size.normal

    // Calculate statistics
    winrate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0.0
    avgWin = winningTrades > 0 ? grossProfit / winningTrades : 0.0
    avgLoss = losingTrades > 0 ? grossLoss / losingTrades : 0.0
    profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999.99 : 0.0
    returnPercent = ((currentCapital - initialCapital) / initialCapital) * 100
    expectancy = totalTrades > 0 ? totalProfitAmount / totalTrades : 0.0

    // Colors
    profitColor = totalProfitAmount >= 0 ? color.green : color.red
    winrateColor = winrate >= 50 ? color.green : color.orange
    drawdownColor = maxDrawdown < 10 ? color.green : maxDrawdown < 20 ? color.orange : color.red

    // Create table
    var table dashboard = table.new(tablePos, 2, 14, bgcolor=color.new(#1e222d, 10), border_color=color.new(#373a46, 0), border_width=1)

    // Header
    table.cell(dashboard, 0, 0, "BACKTESTER", text_color=color.white, text_size=tableSize, bgcolor=color.new(#2962ff, 20))
    table.cell(dashboard, 1, 0, "STATS", text_color=color.white, text_size=tableSize, bgcolor=color.new(#2962ff, 20))

    // Stats rows
    table.cell(dashboard, 0, 1, "Total Trades", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 1, str.tostring(totalTrades), text_color=color.white, text_size=tableSize)

    table.cell(dashboard, 0, 2, "Win Rate", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 2, str.tostring(winrate, "#.##") + "%", text_color=winrateColor, text_size=tableSize)

    table.cell(dashboard, 0, 3, "Wins / Losses", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 3, str.tostring(winningTrades) + " / " + str.tostring(losingTrades), text_color=color.white, text_size=tableSize)

    table.cell(dashboard, 0, 4, "Net Profit", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 4, str.tostring(totalProfitAmount, "#.##"), text_color=profitColor, text_size=tableSize)

    table.cell(dashboard, 0, 5, "Return %", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 5, str.tostring(returnPercent, "#.##") + "%", text_color=profitColor, text_size=tableSize)

    table.cell(dashboard, 0, 6, "Profit Factor", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 6, str.tostring(profitFactor, "#.##"), text_color=profitFactor >= 1 ? color.green : color.red, text_size=tableSize)

    table.cell(dashboard, 0, 7, "Max Drawdown", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 7, str.tostring(maxDrawdown, "#.##") + "%", text_color=drawdownColor, text_size=tableSize)

    table.cell(dashboard, 0, 8, "Avg Win", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 8, str.tostring(avgWin, "#.##"), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 9, "Avg Loss", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 9, str.tostring(avgLoss, "#.##"), text_color=color.red, text_size=tableSize)

    table.cell(dashboard, 0, 10, "Largest Win", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 10, str.tostring(largestWin, "#.##"), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 11, "Largest Loss", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 11, str.tostring(largestLoss, "#.##"), text_color=color.red, text_size=tableSize)

    table.cell(dashboard, 0, 12, "Max Consec. Wins", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 12, str.tostring(maxConsecutiveWins), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 13, "Max Consec. Losses", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 13, str.tostring(maxConsecutiveLosses), text_color=color.red, text_size=tableSize)

// =============================================================================
// EXPORT PLOTS (for connecting to other indicators)
// =============================================================================
// These can be used by other indicators to read the backtester state
plot(inLongTrade ? 1 : 0, "In Long Trade", display=display.none)
plot(inShortTrade ? 1 : 0, "In Short Trade", display=display.none)
plot(entryPrice, "Current Entry Price", display=display.none)
plot(tpPrice, "Current TP Price", display=display.none)
plot(slPrice, "Current SL Price", display=display.none)

// =============================================================================
// WEBHOOK EXPORT PLOTS (for Railway/Supabase integration)
// =============================================================================
// Ready State
plot(longReady ? 1 : 0, "Long Ready State", display=display.none)
plot(shortReady ? 1 : 0, "Short Ready State", display=display.none)

// Projected Entry/TP/SL (updated every bar while ready)
plot(projectedLongEntry, "Projected Long Entry", display=display.none)
plot(projectedLongTP, "Projected Long TP", display=display.none)
plot(projectedLongSL, "Projected Long SL", display=display.none)
plot(projectedShortEntry, "Projected Short Entry", display=display.none)
plot(projectedShortTP, "Projected Short TP", display=display.none)
plot(projectedShortSL, "Projected Short SL", display=display.none)

// ML Feature Exports
plot(atr, "ATR Value", display=display.none)
plot(longZoneWidth, "Long Zone Width (S1-S3)", display=display.none)
plot(shortZoneWidth, "Short Zone Width (R1-R3)", display=display.none)
plot(barsInLongReady, "Bars in Long Ready", display=display.none)
plot(barsInShortReady, "Bars in Short Ready", display=display.none)
plot(distanceToLongEntry, "Distance to Long Entry", display=display.none)
plot(distanceToShortEntry, "Distance to Short Entry", display=display.none)

// Trade outcome for ML (1 = win, -1 = loss, 0 = no exit)
tradeOutcome = longExitTP or shortExitTP ? 1 : longExitSL or shortExitSL ? -1 : 0
plot(tradeOutcome, "Trade Outcome", display=display.none)

// =============================================================================
// ALERT CONDITIONS
// =============================================================================
// Ready state alerts (first entry into zone)
longReadyNew = longReady and not wasLongReady[1]
shortReadyNew = shortReady and not wasShortReady[1]

// Exit ready state (left zone without triggering)
longReadyCancelled = not longReady and wasLongReady[1] and not longSignal
shortReadyCancelled = not shortReady and wasShortReady[1] and not shortSignal

// Trigger alerts (actual entry)
longTriggered = longSignal
shortTriggered = shortSignal

// Exit alerts
longExitAlert = longExitTP or longExitSL
shortExitAlert = shortExitTP or shortExitSL

// Alert conditions (only fire when webhook alerts enabled)
alertcondition(enableWebhookAlerts and longReadyNew, title="READY_LONG", message='{"type":"READY","direction":"LONG","coin":"{{ticker}}","entry":{{plot("Projected Long Entry")}},"tp":{{plot("Projected Long TP")}},"sl":{{plot("Projected Long SL")}},"atr":{{plot("ATR Value")}},"zoneWidth":{{plot("Long Zone Width (S1-S3)")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortReadyNew, title="READY_SHORT", message='{"type":"READY","direction":"SHORT","coin":"{{ticker}}","entry":{{plot("Projected Short Entry")}},"tp":{{plot("Projected Short TP")}},"sl":{{plot("Projected Short SL")}},"atr":{{plot("ATR Value")}},"zoneWidth":{{plot("Short Zone Width (R1-R3)")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longReady, title="UPDATE_LONG", message='{"type":"UPDATE","direction":"LONG","coin":"{{ticker}}","entry":{{plot("Projected Long Entry")}},"tp":{{plot("Projected Long TP")}},"sl":{{plot("Projected Long SL")}},"barsReady":{{plot("Bars in Long Ready")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortReady, title="UPDATE_SHORT", message='{"type":"UPDATE","direction":"SHORT","coin":"{{ticker}}","entry":{{plot("Projected Short Entry")}},"tp":{{plot("Projected Short TP")}},"sl":{{plot("Projected Short SL")}},"barsReady":{{plot("Bars in Short Ready")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longTriggered, title="TRIGGERED_LONG", message='{"type":"TRIGGERED","direction":"LONG","coin":"{{ticker}}","entry":{{plot("Current Entry Price")}},"tp":{{plot("Current TP Price")}},"sl":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortTriggered, title="TRIGGERED_SHORT", message='{"type":"TRIGGERED","direction":"SHORT","coin":"{{ticker}}","entry":{{plot("Current Entry Price")}},"tp":{{plot("Current TP Price")}},"sl":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longExitTP, title="EXIT_LONG_WIN", message='{"type":"EXIT","direction":"LONG","outcome":"WIN","coin":"{{ticker}}","exitPrice":{{plot("Current TP Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longExitSL, title="EXIT_LONG_LOSS", message='{"type":"EXIT","direction":"LONG","outcome":"LOSS","coin":"{{ticker}}","exitPrice":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortExitTP, title="EXIT_SHORT_WIN", message='{"type":"EXIT","direction":"SHORT","outcome":"WIN","coin":"{{ticker}}","exitPrice":{{plot("Current TP Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortExitSL, title="EXIT_SHORT_LOSS", message='{"type":"EXIT","direction":"SHORT","outcome":"LOSS","coin":"{{ticker}}","exitPrice":{{plot("Current SL Price")}},"time":"{{time}}"}')

alertcondition(enableWebhookAlerts and longReadyCancelled, title="CANCELLED_LONG", message='{"type":"CANCELLED","direction":"LONG","coin":"{{ticker}}","time":"{{time}}"}')

alertcondition(enableWebhookAlerts and shortReadyCancelled, title="CANCELLED_SHORT", message='{"type":"CANCELLED","direction":"SHORT","coin":"{{ticker}}","time":"{{time}}"}')
