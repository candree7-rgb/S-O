//@version=6
indicator("Universal Backtester", overlay=true, max_labels_count=500, max_boxes_count=500)

// =============================================================================
// SETTINGS
// =============================================================================

// ─────────────────────────────────────────────────────────────────────────────
// SIGNAL SOURCE
// ─────────────────────────────────────────────────────────────────────────────
groupSignal = "SIGNAL SOURCE"
signalSource = input.string("Multi-Step", "Signal Source", options=["External", "Multi-Step"], tooltip="External: Simple crossover signal\nMulti-Step: LuxAlgo-style step conditions", group=groupSignal)
enableLong = input.bool(true, "Enable Long Trades", tooltip="Allow Long/Buy trades", group=groupSignal)
enableShort = input.bool(true, "Enable Short Trades", tooltip="Allow Short/Sell trades", group=groupSignal)

// External signal inputs (for "External" mode)
extLongSignal = input.source(close, "Long Signal Source", tooltip="Connect to indicator's Long/Buy signal plot (1 = signal, 0 = no signal)", group=groupSignal)
extShortSignal = input.source(close, "Short Signal Source", tooltip="Connect to indicator's Short/Sell signal plot (1 = signal, 0 = no signal)", group=groupSignal)
extLongThreshold = input.float(0.5, "Long Signal Threshold", tooltip="Signal triggers when source crosses above this value", group=groupSignal)
extShortThreshold = input.float(0.5, "Short Signal Threshold", tooltip="Signal triggers when source crosses above this value", group=groupSignal)

// Entry price source
entryPriceSource = input.string("Custom Source", "Entry Price Type", options=["Close", "Open", "High", "Low", "HL2", "HLC3", "OHLC4", "Custom Source"], tooltip="Price used for entry", group=groupSignal)
extLongEntryPrice = input.source(close, "Long Entry Price Source", tooltip="Connect to RZ S1 (Support) for Long entries", group=groupSignal)
extShortEntryPrice = input.source(close, "Short Entry Price Source", tooltip="Connect to RZ R1 (Resistance) for Short entries", group=groupSignal)

// ─────────────────────────────────────────────────────────────────────────────
// LONG CONDITIONS (Multi-Step)
// ─────────────────────────────────────────────────────────────────────────────
groupLongSteps = "LONG CONDITIONS"

// Condition 1 (e.g., Low crossing under S3 = READY)
longC1Enable = input.bool(true, "─── Condition 1 ───", group=groupLongSteps)
longC1PriceType = input.string("Low", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupLongSteps)
longC1PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., RSI)", group=groupLongSteps)
longC1Condition = input.string("Crossing Under", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupLongSteps)
longC1LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupLongSteps)
longC1Level = input.source(close, "  Level Source", tooltip="Connect to RZ S3", group=groupLongSteps)
longC1LevelValue = input.float(30.0, "  Level Value", tooltip="Numeric value (e.g., 30 for RSI)", group=groupLongSteps)
longC1Lookback = input.int(0, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago (0=current). Use for momentum: ATR Band > ATR Band[3]", group=groupLongSteps)
longC1Step = input.int(1, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupLongSteps)

// Condition 2 (e.g., High crossing over S1 = TRIGGERED)
longC2Enable = input.bool(true, "─── Condition 2 ───", group=groupLongSteps)
longC2PriceType = input.string("High", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupLongSteps)
longC2PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., RSI)", group=groupLongSteps)
longC2Condition = input.string("Crossing Over", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupLongSteps)
longC2LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupLongSteps)
longC2Level = input.source(close, "  Level Source", tooltip="Connect to RZ S1", group=groupLongSteps)
longC2LevelValue = input.float(70.0, "  Level Value", tooltip="Numeric value (e.g., 70 for RSI)", group=groupLongSteps)
longC2Lookback = input.int(0, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago (0=current)", group=groupLongSteps)
longC2Step = input.int(2, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupLongSteps)

// Condition 3 (optional, e.g., RSI < 30)
longC3Enable = input.bool(false, "─── Condition 3 ───", group=groupLongSteps)
longC3PriceType = input.string("Custom", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupLongSteps)
longC3PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., RSI, ATR Band)", group=groupLongSteps)
longC3Condition = input.string("Greater Than", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupLongSteps)
longC3LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupLongSteps)
longC3Level = input.source(close, "  Level Source", tooltip="Connect same source for momentum check", group=groupLongSteps)
longC3LevelValue = input.float(30.0, "  Level Value", tooltip="Numeric value (e.g., 30 for RSI)", group=groupLongSteps)
longC3Lookback = input.int(3, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago. E.g., ATR Band > ATR Band[3] = rising", group=groupLongSteps)
longC3Step = input.int(3, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupLongSteps)

// Condition 4 (optional)
longC4Enable = input.bool(false, "─── Condition 4 ───", group=groupLongSteps)
longC4PriceType = input.string("Custom", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupLongSteps)
longC4PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., RSI)", group=groupLongSteps)
longC4Condition = input.string("Greater Than", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupLongSteps)
longC4LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupLongSteps)
longC4Level = input.source(close, "  Level Source", tooltip="Optional condition", group=groupLongSteps)
longC4LevelValue = input.float(50.0, "  Level Value", tooltip="Numeric value (e.g., 50 for RSI)", group=groupLongSteps)
longC4Lookback = input.int(0, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago (0=current)", group=groupLongSteps)
longC4Step = input.int(2, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupLongSteps)

// Step settings
longMaxStepInterval = input.int(10, "Max Step Interval", minval=1, maxval=100, tooltip="Maximum bars between Step 1 and Step 2", group=groupLongSteps)

// ─────────────────────────────────────────────────────────────────────────────
// SHORT CONDITIONS (Multi-Step)
// ─────────────────────────────────────────────────────────────────────────────
groupShortSteps = "SHORT CONDITIONS"

// Condition 1 (e.g., High crossing over R3 = READY)
shortC1Enable = input.bool(true, "─── Condition 1 ───", group=groupShortSteps)
shortC1PriceType = input.string("High", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupShortSteps)
shortC1PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., RSI)", group=groupShortSteps)
shortC1Condition = input.string("Crossing Over", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupShortSteps)
shortC1LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupShortSteps)
shortC1Level = input.source(close, "  Level Source", tooltip="Connect to RZ R3", group=groupShortSteps)
shortC1LevelValue = input.float(70.0, "  Level Value", tooltip="Numeric value (e.g., 70 for RSI)", group=groupShortSteps)
shortC1Lookback = input.int(0, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago (0=current)", group=groupShortSteps)
shortC1Step = input.int(1, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupShortSteps)

// Condition 2 (e.g., Low crossing under R1 = TRIGGERED)
shortC2Enable = input.bool(true, "─── Condition 2 ───", group=groupShortSteps)
shortC2PriceType = input.string("Low", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupShortSteps)
shortC2PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., RSI)", group=groupShortSteps)
shortC2Condition = input.string("Crossing Under", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupShortSteps)
shortC2LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupShortSteps)
shortC2Level = input.source(close, "  Level Source", tooltip="Connect to RZ R1", group=groupShortSteps)
shortC2LevelValue = input.float(30.0, "  Level Value", tooltip="Numeric value (e.g., 30 for RSI)", group=groupShortSteps)
shortC2Lookback = input.int(0, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago (0=current)", group=groupShortSteps)
shortC2Step = input.int(2, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupShortSteps)

// Condition 3 (optional - momentum filter)
shortC3Enable = input.bool(false, "─── Condition 3 ───", group=groupShortSteps)
shortC3PriceType = input.string("Custom", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupShortSteps)
shortC3PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., ATR Upper Band)", group=groupShortSteps)
shortC3Condition = input.string("Less Than", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupShortSteps)
shortC3LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupShortSteps)
shortC3Level = input.source(close, "  Level Source", tooltip="Connect same source for momentum check", group=groupShortSteps)
shortC3LevelValue = input.float(70.0, "  Level Value", tooltip="Numeric value (e.g., 70 for RSI)", group=groupShortSteps)
shortC3Lookback = input.int(3, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago. E.g., ATR Band < ATR Band[3] = falling", group=groupShortSteps)
shortC3Step = input.int(3, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupShortSteps)

// Condition 4 (optional)
shortC4Enable = input.bool(false, "─── Condition 4 ───", group=groupShortSteps)
shortC4PriceType = input.string("Custom", "  Price Type", options=["Close", "Open", "High", "Low", "Custom"], group=groupShortSteps)
shortC4PriceCustom = input.source(close, "  Price Custom", tooltip="Custom source (e.g., RSI)", group=groupShortSteps)
shortC4Condition = input.string("Less Than", "  Condition", options=["Crossing", "Crossing Under", "Crossing Over", "Less Than", "Less Or Equal", "Greater Than", "Greater Or Equal", "Equal To", "Is True (>0)"], group=groupShortSteps)
shortC4LevelType = input.string("Source", "  Level Type", options=["Source", "Value"], group=groupShortSteps)
shortC4Level = input.source(close, "  Level Source", tooltip="Optional condition", group=groupShortSteps)
shortC4LevelValue = input.float(50.0, "  Level Value", tooltip="Numeric value (e.g., 50 for RSI)", group=groupShortSteps)
shortC4Lookback = input.int(0, "  Lookback", minval=0, maxval=50, tooltip="Compare Level from N bars ago (0=current)", group=groupShortSteps)
shortC4Step = input.int(2, "  Step", minval=1, maxval=3, tooltip="1=READY, 2=TRIGGERED, 3=FILTER", group=groupShortSteps)

// Step settings
shortMaxStepInterval = input.int(10, "Max Step Interval", minval=1, maxval=100, tooltip="Maximum bars between Step 1 and Step 2", group=groupShortSteps)

// ─────────────────────────────────────────────────────────────────────────────
// TP/SL SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupTPSL = "TP / SL SETTINGS"
tpType = input.string("ATR", "TP Type", options=["ATR", "Percent", "Fixed Points", "Custom Source"], group=groupTPSL)
slType = input.string("ATR", "SL Type", options=["ATR", "Percent", "Fixed Points", "Custom Source"], group=groupTPSL)

// ATR Settings
atrLength = input.int(14, "ATR Length", minval=1, group=groupTPSL)
tpAtrMult = input.float(2.0, "TP ATR Multiplier", minval=0.1, step=0.1, tooltip="TP = Entry ± (ATR × Multiplier)", group=groupTPSL)
slAtrMult = input.float(1.0, "SL ATR Multiplier", minval=0.1, step=0.1, tooltip="SL = Entry ∓ (ATR × Multiplier)", group=groupTPSL)

// Percent Settings
tpPercent = input.float(2.0, "TP Percent %", minval=0.1, step=0.1, group=groupTPSL)
slPercent = input.float(1.0, "SL Percent %", minval=0.1, step=0.1, group=groupTPSL)

// Fixed Points Settings
tpPoints = input.float(100, "TP Points", minval=1, group=groupTPSL)
slPoints = input.float(50, "SL Points", minval=1, group=groupTPSL)

// Custom Source (connect to RZ levels etc)
extTpSource = input.source(close, "Custom TP Source", tooltip="Connect to TP level from indicator", group=groupTPSL)
extSlSource = input.source(close, "Custom SL Source", tooltip="Connect to SL level from indicator", group=groupTPSL)

// ─────────────────────────────────────────────────────────────────────────────
// ACCURACY SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupAccuracy = "ACCURACY SETTINGS"
signalBarMode = input.string("TP First", "Signal Bar Conflict", options=["TP First", "Pessimistic", "Open-Based"], tooltip="On SIGNAL candle when both TP+SL hit: TP First recommended (cross = good direction)", group=groupAccuracy)
nextBarMode = input.string("Pessimistic", "Next Bar Conflict", options=["Pessimistic", "Optimistic", "Open-Based"], tooltip="On candles AFTER signal when both TP+SL hit", group=groupAccuracy)

// ─────────────────────────────────────────────────────────────────────────────
// FEES SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupFees = "FEES SETTINGS"
useFees = input.bool(true, "Enable Fees", group=groupFees)
feeType = input.string("Percent", "Fee Type", options=["Percent", "Fixed"], group=groupFees)
entryFee = input.float(0.04, "Entry Fee %", minval=0, step=0.01, tooltip="Fee on entry (e.g. 0.04% for Binance maker)", group=groupFees)
exitFee = input.float(0.04, "Exit Fee %", minval=0, step=0.01, tooltip="Fee on exit (e.g. 0.04% for Binance maker)", group=groupFees)
fixedFeePerTrade = input.float(0, "Fixed Fee per Trade", minval=0, tooltip="Fixed fee amount per trade", group=groupFees)

// ─────────────────────────────────────────────────────────────────────────────
// POSITION SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupPosition = "POSITION SETTINGS"
initialCapital = input.float(10000, "Initial Capital", minval=100, group=groupPosition)
leverage = input.float(20, "Leverage", minval=1, maxval=125, step=1, tooltip="Trading leverage (e.g., 20x)", group=groupPosition)
useCompounding = input.bool(true, "Use Compounding", tooltip="Position size based on current equity (true) or initial capital (false)", group=groupPosition)
positionSizing = input.string("Percent", "Position Sizing", options=["Percent", "Fixed", "Risk-Based"], group=groupPosition)
positionPercent = input.float(5, "Position Size %", minval=0.1, maxval=100, step=0.1, tooltip="Percent of equity per trade (before risk adjustment)", group=groupPosition)
fixedPositionSize = input.float(1000, "Fixed Position Size", minval=1, group=groupPosition)
maxRiskPercent = input.float(2, "Max Risk per Trade %", minval=0.1, maxval=50, step=0.1, tooltip="Maximum equity loss per trade. Position size reduced if SL would exceed this.", group=groupPosition)
useMaxRiskCap = input.bool(true, "Enable Max Risk Cap", tooltip="Automatically reduce position if SL exceeds max risk", group=groupPosition)
allowPyramiding = input.bool(false, "Allow Pyramiding", tooltip="Allow multiple positions at once", group=groupPosition)

// ─────────────────────────────────────────────────────────────────────────────
// DASHBOARD SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupDashboard = "DASHBOARD"
showDashboard = input.bool(true, "Show Dashboard", group=groupDashboard)
dashboardPosition = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=groupDashboard)
dashboardSize = input.string("Normal", "Dashboard Size", options=["Tiny", "Small", "Normal", "Large"], group=groupDashboard)
showTradesOnChart = input.bool(true, "Show Trades on Chart", group=groupDashboard)
showTPSLLines = input.bool(true, "Show TP/SL Lines", group=groupDashboard)

// ─────────────────────────────────────────────────────────────────────────────
// TRAILING SL SETTINGS
// ─────────────────────────────────────────────────────────────────────────────
groupTrailSL = "TRAILING SL"
useTrailingSL = input.bool(true, "Enable Trailing SL", tooltip="Move SL to profit when price reaches TP threshold", group=groupTrailSL)
trailTPThreshold = input.float(85.0, "TP Threshold %", minval=10, maxval=99, step=1, tooltip="When price reaches this % of entry-to-TP distance, move SL", group=groupTrailSL)
trailSLMove = input.float(30.0, "Move SL to % above Entry", minval=1, maxval=90, step=1, tooltip="New SL = Entry + this % of entry-to-TP distance (locks in profit)", group=groupTrailSL)

// ─────────────────────────────────────────────────────────────────────────────
// WEBHOOK / ALERTS
// ─────────────────────────────────────────────────────────────────────────────
groupWebhook = "WEBHOOK / ALERTS"
enableWebhookAlerts = input.bool(false, "Enable Webhook Alerts", tooltip="Enable alerts for Railway/Supabase webhook integration", group=groupWebhook)

// ML Feature inputs (optional - for extra data in alerts)
extRSI = input.source(close, "RSI Source (ML)", tooltip="Connect to RSI for ML data export", group=groupWebhook)
extVolume = input.source(close, "Volume Ratio (ML)", tooltip="Connect to volume ratio for ML data", group=groupWebhook)

// =============================================================================
// CALCULATIONS
// =============================================================================

// ATR Calculation
atr = ta.atr(atrLength)

// Get Entry Price for Long trades
getLongEntryPrice() =>
    switch entryPriceSource
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        "HL2" => hl2
        "HLC3" => hlc3
        "OHLC4" => ohlc4
        "Custom Source" => extLongEntryPrice
        => close

// Get Entry Price for Short trades
getShortEntryPrice() =>
    switch entryPriceSource
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        "HL2" => hl2
        "HLC3" => hlc3
        "OHLC4" => ohlc4
        "Custom Source" => extShortEntryPrice
        => close

// Calculate TP distance
getTPDistance() =>
    switch tpType
        "ATR" => atr * tpAtrMult
        "Percent" => close * (tpPercent / 100)
        "Fixed Points" => tpPoints * syminfo.mintick
        "Custom Source" => math.abs(extTpSource - close)
        => atr * tpAtrMult

// Calculate SL distance
getSLDistance() =>
    switch slType
        "ATR" => atr * slAtrMult
        "Percent" => close * (slPercent / 100)
        "Fixed Points" => slPoints * syminfo.mintick
        "Custom Source" => math.abs(extSlSource - close)
        => atr * slAtrMult

// =============================================================================
// MULTI-STEP SIGNAL LOGIC
// =============================================================================

// Helper: Get price based on selection (with custom source support)
getStepPrice(priceType, customSource) =>
    switch priceType
        "Close" => close
        "Open" => open
        "High" => high
        "Low" => low
        "Custom" => customSource
        => close

// Helper: Get level based on type (source or fixed value) with lookback
// Lookback shifts the level by N bars (for momentum comparison)
getStepLevel(levelType, levelSource, levelValue, lookback) =>
    baseLevel = levelType == "Value" ? levelValue : levelSource
    lookback > 0 ? baseLevel[lookback] : baseLevel

// Helper: Check step condition (with "Crossing" = either direction)
// Lookback: compare Price (current) vs Level (N bars ago)
checkConditionFull(priceType, customSource, condition, levelType, levelSource, levelValue, lookback) =>
    price = getStepPrice(priceType, customSource)
    level = getStepLevel(levelType, levelSource, levelValue, lookback)
    switch condition
        "Crossing" => ta.crossunder(price, level) or ta.crossover(price, level)
        "Crossing Under" => ta.crossunder(price, level)
        "Crossing Over" => ta.crossover(price, level)
        "Less Than" => price < level
        "Less Or Equal" => price <= level
        "Greater Than" => price > level
        "Greater Or Equal" => price >= level
        "Equal To" => price == level
        "Is True (>0)" => price > 0
        => false

// Helper: Check if condition is a crossing/trigger type (fires once)
isTriggerCondition(condition) =>
    condition == "Crossing" or condition == "Crossing Under" or condition == "Crossing Over"

// Check each Long condition (with lookback support for momentum filters)
longC1Met = longC1Enable ? checkConditionFull(longC1PriceType, longC1PriceCustom, longC1Condition, longC1LevelType, longC1Level, longC1LevelValue, longC1Lookback) : true
longC2Met = longC2Enable ? checkConditionFull(longC2PriceType, longC2PriceCustom, longC2Condition, longC2LevelType, longC2Level, longC2LevelValue, longC2Lookback) : true
longC3Met = longC3Enable ? checkConditionFull(longC3PriceType, longC3PriceCustom, longC3Condition, longC3LevelType, longC3Level, longC3LevelValue, longC3Lookback) : true
longC4Met = longC4Enable ? checkConditionFull(longC4PriceType, longC4PriceCustom, longC4Condition, longC4LevelType, longC4Level, longC4LevelValue, longC4Lookback) : true

// Check each Short condition (with lookback support for momentum filters)
shortC1Met = shortC1Enable ? checkConditionFull(shortC1PriceType, shortC1PriceCustom, shortC1Condition, shortC1LevelType, shortC1Level, shortC1LevelValue, shortC1Lookback) : true
shortC2Met = shortC2Enable ? checkConditionFull(shortC2PriceType, shortC2PriceCustom, shortC2Condition, shortC2LevelType, shortC2Level, shortC2LevelValue, shortC2Lookback) : true
shortC3Met = shortC3Enable ? checkConditionFull(shortC3PriceType, shortC3PriceCustom, shortC3Condition, shortC3LevelType, shortC3Level, shortC3LevelValue, shortC3Lookback) : true
shortC4Met = shortC4Enable ? checkConditionFull(shortC4PriceType, shortC4PriceCustom, shortC4Condition, shortC4LevelType, shortC4Level, shortC4LevelValue, shortC4Lookback) : true

// Check which conditions are assigned to which steps
longC1OnStep1 = longC1Enable and longC1Step == 1
longC2OnStep1 = longC2Enable and longC2Step == 1
longC3OnStep1 = longC3Enable and longC3Step == 1
longC4OnStep1 = longC4Enable and longC4Step == 1
longHasAnyStep1 = longC1OnStep1 or longC2OnStep1 or longC3OnStep1 or longC4OnStep1

longC1OnStep2 = longC1Enable and longC1Step == 2
longC2OnStep2 = longC2Enable and longC2Step == 2
longC3OnStep2 = longC3Enable and longC3Step == 2
longC4OnStep2 = longC4Enable and longC4Step == 2
longHasAnyStep2 = longC1OnStep2 or longC2OnStep2 or longC3OnStep2 or longC4OnStep2

// Long Step 1 conditions (READY) - each condition check
longC1Step1Ok = not longC1OnStep1 or longC1Met
longC2Step1Ok = not longC2OnStep1 or longC2Met
longC3Step1Ok = not longC3OnStep1 or longC3Met
longC4Step1Ok = not longC4OnStep1 or longC4Met
longStep1Conditions = longC1Step1Ok and longC2Step1Ok and longC3Step1Ok and longC4Step1Ok

// Check for trigger conditions on Step 1 (for edge detection)
longC1IsTrigger1 = longC1OnStep1 and isTriggerCondition(longC1Condition)
longC2IsTrigger1 = longC2OnStep1 and isTriggerCondition(longC2Condition)
longC3IsTrigger1 = longC3OnStep1 and isTriggerCondition(longC3Condition)
longC4IsTrigger1 = longC4OnStep1 and isTriggerCondition(longC4Condition)
longHasStep1Trigger = longC1IsTrigger1 or longC2IsTrigger1 or longC3IsTrigger1 or longC4IsTrigger1

// Step 1 fires when: conditions met AND (has trigger that fired OR no triggers but state changed)
// For simplicity: if has trigger conditions, require them; if only state conditions, use edge detection
var bool longStep1ConditionsPrev = false
longStep1Edge = longStep1Conditions and not longStep1ConditionsPrev
longStep1ConditionsPrev := longStep1Conditions

// Step 1 is met when: has trigger that fires, OR all state conditions become true (edge)
longStep1AllMet = longHasAnyStep1 and longStep1Conditions and (longHasStep1Trigger or longStep1Edge)

// Long Step 2 conditions (TRIGGERED) - each condition check
longC1Step2Ok = not longC1OnStep2 or longC1Met
longC2Step2Ok = not longC2OnStep2 or longC2Met
longC3Step2Ok = not longC3OnStep2 or longC3Met
longC4Step2Ok = not longC4OnStep2 or longC4Met
longStep2Conditions = longC1Step2Ok and longC2Step2Ok and longC3Step2Ok and longC4Step2Ok

// Check for trigger conditions on Step 2
longC1IsTrigger2 = longC1OnStep2 and isTriggerCondition(longC1Condition)
longC2IsTrigger2 = longC2OnStep2 and isTriggerCondition(longC2Condition)
longC3IsTrigger2 = longC3OnStep2 and isTriggerCondition(longC3Condition)
longC4IsTrigger2 = longC4OnStep2 and isTriggerCondition(longC4Condition)
longHasStep2Trigger = longC1IsTrigger2 or longC2IsTrigger2 or longC3IsTrigger2 or longC4IsTrigger2

// Edge detection for Step 2 state conditions
var bool longStep2ConditionsPrev = false
longStep2Edge = longStep2Conditions and not longStep2ConditionsPrev
longStep2ConditionsPrev := longStep2Conditions

// Step 2 is met when: no Step 2 conditions (immediate), OR has trigger that fires, OR state edge
longStep2AllMet = not longHasAnyStep2 or (longStep2Conditions and (longHasStep2Trigger or longStep2Edge))

// Long Step 3 conditions (FILTER - must be met continuously while Step 1 active)
longC1Step3Ok = not longC1Enable or longC1Step != 3 or longC1Met
longC2Step3Ok = not longC2Enable or longC2Step != 3 or longC2Met
longC3Step3Ok = not longC3Enable or longC3Step != 3 or longC3Met
longC4Step3Ok = not longC4Enable or longC4Step != 3 or longC4Met
longStep3AllMet = longC1Step3Ok and longC2Step3Ok and longC3Step3Ok and longC4Step3Ok

// Check which conditions are assigned to which steps (Short)
shortC1OnStep1 = shortC1Enable and shortC1Step == 1
shortC2OnStep1 = shortC2Enable and shortC2Step == 1
shortC3OnStep1 = shortC3Enable and shortC3Step == 1
shortC4OnStep1 = shortC4Enable and shortC4Step == 1
shortHasAnyStep1 = shortC1OnStep1 or shortC2OnStep1 or shortC3OnStep1 or shortC4OnStep1

shortC1OnStep2 = shortC1Enable and shortC1Step == 2
shortC2OnStep2 = shortC2Enable and shortC2Step == 2
shortC3OnStep2 = shortC3Enable and shortC3Step == 2
shortC4OnStep2 = shortC4Enable and shortC4Step == 2
shortHasAnyStep2 = shortC1OnStep2 or shortC2OnStep2 or shortC3OnStep2 or shortC4OnStep2

// Short Step 1 conditions (READY) - each condition check
shortC1Step1Ok = not shortC1OnStep1 or shortC1Met
shortC2Step1Ok = not shortC2OnStep1 or shortC2Met
shortC3Step1Ok = not shortC3OnStep1 or shortC3Met
shortC4Step1Ok = not shortC4OnStep1 or shortC4Met
shortStep1Conditions = shortC1Step1Ok and shortC2Step1Ok and shortC3Step1Ok and shortC4Step1Ok

// Check for trigger conditions on Step 1
shortC1IsTrigger1 = shortC1OnStep1 and isTriggerCondition(shortC1Condition)
shortC2IsTrigger1 = shortC2OnStep1 and isTriggerCondition(shortC2Condition)
shortC3IsTrigger1 = shortC3OnStep1 and isTriggerCondition(shortC3Condition)
shortC4IsTrigger1 = shortC4OnStep1 and isTriggerCondition(shortC4Condition)
shortHasStep1Trigger = shortC1IsTrigger1 or shortC2IsTrigger1 or shortC3IsTrigger1 or shortC4IsTrigger1

// Edge detection for Step 1 state conditions
var bool shortStep1ConditionsPrev = false
shortStep1Edge = shortStep1Conditions and not shortStep1ConditionsPrev
shortStep1ConditionsPrev := shortStep1Conditions

// Step 1 is met when: has trigger that fires, OR all state conditions become true (edge)
shortStep1AllMet = shortHasAnyStep1 and shortStep1Conditions and (shortHasStep1Trigger or shortStep1Edge)

// Short Step 2 conditions (TRIGGERED) - each condition check
shortC1Step2Ok = not shortC1OnStep2 or shortC1Met
shortC2Step2Ok = not shortC2OnStep2 or shortC2Met
shortC3Step2Ok = not shortC3OnStep2 or shortC3Met
shortC4Step2Ok = not shortC4OnStep2 or shortC4Met
shortStep2Conditions = shortC1Step2Ok and shortC2Step2Ok and shortC3Step2Ok and shortC4Step2Ok

// Check for trigger conditions on Step 2
shortC1IsTrigger2 = shortC1OnStep2 and isTriggerCondition(shortC1Condition)
shortC2IsTrigger2 = shortC2OnStep2 and isTriggerCondition(shortC2Condition)
shortC3IsTrigger2 = shortC3OnStep2 and isTriggerCondition(shortC3Condition)
shortC4IsTrigger2 = shortC4OnStep2 and isTriggerCondition(shortC4Condition)
shortHasStep2Trigger = shortC1IsTrigger2 or shortC2IsTrigger2 or shortC3IsTrigger2 or shortC4IsTrigger2

// Edge detection for Step 2 state conditions
var bool shortStep2ConditionsPrev = false
shortStep2Edge = shortStep2Conditions and not shortStep2ConditionsPrev
shortStep2ConditionsPrev := shortStep2Conditions

// Step 2 is met when: no Step 2 conditions (immediate), OR has trigger that fires, OR state edge
shortStep2AllMet = not shortHasAnyStep2 or (shortStep2Conditions and (shortHasStep2Trigger or shortStep2Edge))

// Short Step 3 conditions (FILTER - must be met continuously while Step 1 active)
shortC1Step3Ok = not shortC1Enable or shortC1Step != 3 or shortC1Met
shortC2Step3Ok = not shortC2Enable or shortC2Step != 3 or shortC2Met
shortC3Step3Ok = not shortC3Enable or shortC3Step != 3 or shortC3Met
shortC4Step3Ok = not shortC4Enable or shortC4Step != 3 or shortC4Met
shortStep3AllMet = shortC1Step3Ok and shortC2Step3Ok and shortC3Step3Ok and shortC4Step3Ok

// Trade state (declared early for step logic)
var bool inLongTrade = false
var bool inShortTrade = false

// Multi-step state tracking
var bool longStep1Active = false      // Step 1 has been triggered (READY)
var int longStep1Bar = na             // Bar where Step 1 triggered
var bool shortStep1Active = false
var int shortStep1Bar = na

// Long Step State Machine
// Only activate Step 1 if NO trade is currently open (same coin can't have 2 trades)
if longStep1AllMet and not longStep1Active and not inLongTrade and not inShortTrade
    longStep1Active := true
    longStep1Bar := bar_index

// Check if step interval expired OR Step 3 filter fails
if longStep1Active and ((bar_index - longStep1Bar) > longMaxStepInterval or not longStep3AllMet)
    longStep1Active := false
    longStep1Bar := na

// Short Step State Machine
// Only activate Step 1 if NO trade is currently open (same coin can't have 2 trades)
if shortStep1AllMet and not shortStep1Active and not inLongTrade and not inShortTrade
    shortStep1Active := true
    shortStep1Bar := bar_index

// Check if step interval expired OR Step 3 filter fails
if shortStep1Active and ((bar_index - shortStep1Bar) > shortMaxStepInterval or not shortStep3AllMet)
    shortStep1Active := false
    shortStep1Bar := na

// Signal Detection
var bool longSignal = false
var bool shortSignal = false

if signalSource == "External"
    longSignal := enableLong and ta.crossover(extLongSignal, extLongThreshold)
    shortSignal := enableShort and ta.crossover(extShortSignal, extShortThreshold)
else  // Multi-Step mode
    // Single-step mode: if no Step 2 conditions, trigger immediately when Step 1 fires
    // Two-step mode: Step 1 must be active + Step 2 met + NOT on same candle

    // Long signal detection
    if longHasAnyStep2
        // Two-step mode: require different candle
        longSignal := enableLong and longStep1Active and bar_index > longStep1Bar and longStep2AllMet and longStep3AllMet
    else
        // Single-step mode: trigger immediately when Step 1 fires (same candle OK)
        longSignal := enableLong and longStep1AllMet and longStep3AllMet

    // Short signal detection
    if shortHasAnyStep2
        // Two-step mode: require different candle
        shortSignal := enableShort and shortStep1Active and bar_index > shortStep1Bar and shortStep2AllMet and shortStep3AllMet
    else
        // Single-step mode: trigger immediately when Step 1 fires (same candle OK)
        shortSignal := enableShort and shortStep1AllMet and shortStep3AllMet

    // Reset step state after signal
    if longSignal
        longStep1Active := false
        longStep1Bar := na
    if shortSignal
        shortStep1Active := false
        shortStep1Bar := na

// =============================================================================
// READY STATE TRACKING (for Webhook System)
// =============================================================================

// Ready state = Step 1 is active (waiting for Step 2)
longReady = longStep1Active
shortReady = shortStep1Active

// Track ready state changes
var bool wasLongReady = false
var bool wasShortReady = false
var int longReadyBar = na
var int shortReadyBar = na
var int barsInLongReady = 0
var int barsInShortReady = 0

// Long ready state tracking
if longReady and not wasLongReady
    longReadyBar := bar_index
    barsInLongReady := 0
if longReady
    barsInLongReady += 1
if not longReady
    barsInLongReady := 0
wasLongReady := longReady

// Short ready state tracking
if shortReady and not wasShortReady
    shortReadyBar := bar_index
    barsInShortReady := 0
if shortReady
    barsInShortReady += 1
if not shortReady
    barsInShortReady := 0
wasShortReady := shortReady

// Calculate projected TP/SL for ready states (before trade triggers)
projectedLongEntry = getLongEntryPrice()
projectedShortEntry = getShortEntryPrice()
projectedLongTP = projectedLongEntry + getTPDistance()
projectedLongSL = projectedLongEntry - getSLDistance()
projectedShortTP = projectedShortEntry - getTPDistance()
projectedShortSL = projectedShortEntry + getSLDistance()

// Zone width calculations (for ML) - uses condition levels
// Assumes C1 = Zone 3 (S3/R3), C2 = Zone 1 (S1/R1)
longZoneWidth = math.abs(longC2Level - longC1Level)
shortZoneWidth = math.abs(shortC2Level - shortC1Level)
distanceToLongEntry = math.abs(close - projectedLongEntry)
distanceToShortEntry = math.abs(close - projectedShortEntry)

// =============================================================================
// TRADE TRACKING
// =============================================================================

// Trade State Variables (inLongTrade/inShortTrade declared earlier for step logic)
var float entryPrice = na
var float tpPrice = na
var float slPrice = na
var float originalSLPrice = na  // Original SL before trailing
var int entryBar = na
var int tradeDirection = 0  // 1 = long, -1 = short
var bool trailingSLActivated = false  // Has trailing SL been triggered?

// Statistics Variables
var int totalTrades = 0
var int winningTrades = 0
var int losingTrades = 0
var float totalProfitPercent = 0.0
var float totalProfitAmount = 0.0
var float currentCapital = initialCapital
var float maxCapital = initialCapital
var float maxDrawdown = 0.0
var float grossProfit = 0.0
var float grossLoss = 0.0
var float largestWin = 0.0
var float largestLoss = 0.0
var int consecutiveWins = 0
var int consecutiveLosses = 0
var int maxConsecutiveWins = 0
var int maxConsecutiveLosses = 0
var int currentStreak = 0

// Position Size Calculation with Leverage and Risk Management
// slDistancePercent = how far SL is from entry in percent (e.g., 0.65 for 0.65%)
getPositionSize(slDistancePercent) =>
    // Base equity (compounding or not)
    equity = useCompounding ? currentCapital : initialCapital

    // Calculate base position size
    float basePosition = 0.0
    if positionSizing == "Percent"
        basePosition := equity * (positionPercent / 100)
    else if positionSizing == "Fixed"
        basePosition := fixedPositionSize
    else  // Risk-Based: position sized so that SL = maxRiskPercent loss
        // Position = (Equity × MaxRisk%) / (SL% × Leverage)
        if slDistancePercent > 0
            basePosition := (equity * (maxRiskPercent / 100)) / (slDistancePercent / 100 * leverage)
        else
            basePosition := equity * (positionPercent / 100)

    // Apply Max Risk Cap if enabled (for Percent and Fixed modes)
    float finalPosition = basePosition
    if useMaxRiskCap and positionSizing != "Risk-Based" and slDistancePercent > 0
        // Calculate what the loss would be with base position
        // Loss = Position × SL% × Leverage
        potentialLoss = basePosition * (slDistancePercent / 100) * leverage
        maxAllowedLoss = equity * (maxRiskPercent / 100)

        // If potential loss exceeds max allowed, reduce position
        if potentialLoss > maxAllowedLoss
            // Solve for position: maxAllowedLoss = Position × SL% × Leverage
            // Position = maxAllowedLoss / (SL% × Leverage)
            finalPosition := maxAllowedLoss / (slDistancePercent / 100 * leverage)

    finalPosition

// Fee Calculation
calculateFees(tradeValue) =>
    if not useFees
        0.0
    else if feeType == "Percent"
        tradeValue * ((entryFee + exitFee) / 100)
    else
        fixedFeePerTrade

// Check if TP or SL hit
// Signal Bar Logic: For Reversal Zone strategy, entry happens when price EXITS the zone:
//   - LONG: Entry when High crosses over S1 (price going UP out of zone)
//   - SHORT: Entry when Low crosses under R1 (price going DOWN out of zone)
//   - The Low/High BEFORE the crossing was before entry → SL impossible on signal bar
//   - Only check TP on signal bar, SL check starts from NEXT bar
checkTPSLHit(isLong, tp, sl, isSignalBar) =>
    tpHit = false
    slHit = false

    if isSignalBar
        // SIGNAL BAR: SL is NEVER checked (the low/high was before entry)
        // Only check if TP was reached on this bar
        if isLong
            tpHit := high >= tp
            slHit := false  // Impossible - low was before entry
        else
            tpHit := low <= tp
            slHit := false  // Impossible - high was before entry
    else
        // NORMAL BARS (after signal): Standard high/low check
        if isLong
            tpHit := high >= tp
            slHit := low <= sl
        else
            tpHit := low <= tp
            slHit := high >= sl

    // Determine result
    result = 0  // 0 = none, 1 = TP, -1 = SL

    if tpHit and slHit
        // Both hit on same bar - use conflict resolution (only on non-signal bars)
        if nextBarMode == "Optimistic"
            result := 1
        else if nextBarMode == "Pessimistic"
            result := -1
        else  // Open-Based
            if isLong
                result := open > (tp + sl) / 2 ? -1 : 1
            else
                result := open < (tp + sl) / 2 ? -1 : 1
    else if tpHit
        result := 1
    else if slHit
        result := -1

    result

// =============================================================================
// TRADE EXECUTION LOGIC
// =============================================================================

// Additional trade tracking variables
var float tradePositionSize = na
var float tradeSLDistancePercent = na

// Entry Logic
if longSignal and not inLongTrade and (allowPyramiding or not inShortTrade)
    if inShortTrade
        // Close short first (simplified - would need proper exit handling)
        inShortTrade := false

    inLongTrade := true
    entryPrice := getLongEntryPrice()
    tpPrice := entryPrice + getTPDistance()
    slPrice := entryPrice - getSLDistance()
    entryBar := bar_index
    tradeDirection := 1

    // Calculate SL distance in percent and position size
    tradeSLDistancePercent := math.abs(entryPrice - slPrice) / entryPrice * 100
    tradePositionSize := getPositionSize(tradeSLDistancePercent)

if shortSignal and not inShortTrade and (allowPyramiding or not inLongTrade)
    if inLongTrade
        inLongTrade := false

    inShortTrade := true
    entryPrice := getShortEntryPrice()
    tpPrice := entryPrice - getTPDistance()
    slPrice := entryPrice + getSLDistance()
    entryBar := bar_index
    tradeDirection := -1

    // Calculate SL distance in percent and position size
    tradeSLDistancePercent := math.abs(slPrice - entryPrice) / entryPrice * 100
    tradePositionSize := getPositionSize(tradeSLDistancePercent)

// =============================================================================
// TRAILING SL LOGIC
// =============================================================================
// When price reaches X% of entry-to-TP distance, move SL to Y% above entry
// This locks in profit and protects against reversal

if useTrailingSL and not trailingSLActivated
    if inLongTrade and not na(entryPrice) and not na(tpPrice)
        tpDistance = tpPrice - entryPrice
        threshold = entryPrice + tpDistance * (trailTPThreshold / 100)
        if high >= threshold
            newSL = entryPrice + tpDistance * (trailSLMove / 100)
            if newSL > slPrice
                originalSLPrice := na(originalSLPrice) ? slPrice : originalSLPrice
                slPrice := newSL
                trailingSLActivated := true

    if inShortTrade and not na(entryPrice) and not na(tpPrice)
        tpDistance = entryPrice - tpPrice
        threshold = entryPrice - tpDistance * (trailTPThreshold / 100)
        if low <= threshold
            newSL = entryPrice - tpDistance * (trailSLMove / 100)
            if newSL < slPrice
                originalSLPrice := na(originalSLPrice) ? slPrice : originalSLPrice
                slPrice := newSL
                trailingSLActivated := true

// Variables for exit visualization
var bool longExitTP = false
var bool longExitSL = false
var bool shortExitTP = false
var bool shortExitSL = false
var float exitPriceViz = na
longExitTP := false
longExitSL := false
shortExitTP := false
shortExitSL := false

// Exit Logic - Check TP/SL
if inLongTrade and bar_index >= entryBar
    isSignalBar = bar_index == entryBar
    exitResult = checkTPSLHit(true, tpPrice, slPrice, isSignalBar)

    if exitResult != 0
        posSize = tradePositionSize

        float exitPrice = exitResult == 1 ? tpPrice : slPrice
        // PnL with leverage: price move % × leverage × position
        float priceChangePercent = ((exitPrice - entryPrice) / entryPrice) * 100
        float pnlPercent = priceChangePercent * leverage
        float pnlAmount = posSize * (pnlPercent / 100)
        float fees = calculateFees(posSize)

        pnlAmount := pnlAmount - fees
        pnlPercent := (pnlAmount / posSize) * 100

        totalTrades += 1
        totalProfitPercent += pnlPercent
        totalProfitAmount += pnlAmount
        currentCapital += pnlAmount

        // Track exit for visualization
        exitPriceViz := exitPrice
        if exitResult == 1
            longExitTP := true
        else
            longExitSL := true

        if pnlAmount > 0
            winningTrades += 1
            grossProfit += pnlAmount
            largestWin := math.max(largestWin, pnlAmount)
            if currentStreak >= 0
                currentStreak += 1
            else
                currentStreak := 1
            consecutiveWins := currentStreak
            maxConsecutiveWins := math.max(maxConsecutiveWins, consecutiveWins)
        else
            losingTrades += 1
            grossLoss += math.abs(pnlAmount)
            largestLoss := math.max(largestLoss, math.abs(pnlAmount))
            if currentStreak <= 0
                currentStreak -= 1
            else
                currentStreak := -1
            consecutiveLosses := math.abs(currentStreak)
            maxConsecutiveLosses := math.max(maxConsecutiveLosses, consecutiveLosses)

        maxCapital := math.max(maxCapital, currentCapital)
        drawdown = ((maxCapital - currentCapital) / maxCapital) * 100
        maxDrawdown := math.max(maxDrawdown, drawdown)

        inLongTrade := false
        entryPrice := na
        tpPrice := na
        slPrice := na
        originalSLPrice := na
        tradePositionSize := na
        trailingSLActivated := false

if inShortTrade and bar_index >= entryBar
    isSignalBar = bar_index == entryBar
    exitResult = checkTPSLHit(false, tpPrice, slPrice, isSignalBar)

    if exitResult != 0
        posSize = tradePositionSize

        float exitPrice = exitResult == 1 ? tpPrice : slPrice
        // PnL with leverage: price move % × leverage × position
        float priceChangePercent = ((entryPrice - exitPrice) / entryPrice) * 100
        float pnlPercent = priceChangePercent * leverage
        float pnlAmount = posSize * (pnlPercent / 100)
        float fees = calculateFees(posSize)

        pnlAmount := pnlAmount - fees
        pnlPercent := (pnlAmount / posSize) * 100

        totalTrades += 1
        totalProfitPercent += pnlPercent
        totalProfitAmount += pnlAmount
        currentCapital += pnlAmount

        // Track exit for visualization
        exitPriceViz := exitPrice
        if exitResult == 1
            shortExitTP := true
        else
            shortExitSL := true

        if pnlAmount > 0
            winningTrades += 1
            grossProfit += pnlAmount
            largestWin := math.max(largestWin, pnlAmount)
            if currentStreak >= 0
                currentStreak += 1
            else
                currentStreak := 1
            consecutiveWins := currentStreak
            maxConsecutiveWins := math.max(maxConsecutiveWins, consecutiveWins)
        else
            losingTrades += 1
            grossLoss += math.abs(pnlAmount)
            largestLoss := math.max(largestLoss, math.abs(pnlAmount))
            if currentStreak <= 0
                currentStreak -= 1
            else
                currentStreak := -1
            consecutiveLosses := math.abs(currentStreak)
            maxConsecutiveLosses := math.max(maxConsecutiveLosses, consecutiveLosses)

        maxCapital := math.max(maxCapital, currentCapital)
        drawdown = ((maxCapital - currentCapital) / maxCapital) * 100
        maxDrawdown := math.max(maxDrawdown, drawdown)

        inShortTrade := false
        entryPrice := na
        tpPrice := na
        slPrice := na
        originalSLPrice := na
        tradePositionSize := na
        trailingSLActivated := false

// =============================================================================
// VISUALIZATION
// =============================================================================

// Variables for tracking trade visualization
var float lastEntryPrice = na
var float lastTpPrice = na
var float lastSlPrice = na
var float lastExitPrice = na
var int lastEntryBar = na
var int lastExitBar = na
var int lastTradeDir = 0
var bool lastTradeWin = false

// Plot TP/SL Lines for current trade
plot(showTPSLLines and inLongTrade ? tpPrice : na, "Long TP", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inLongTrade ? slPrice : na, "Long SL", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inLongTrade ? entryPrice : na, "Long Entry", color=color.new(color.blue, 0), style=plot.style_linebr, linewidth=2)

plot(showTPSLLines and inShortTrade ? tpPrice : na, "Short TP", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inShortTrade ? slPrice : na, "Short SL", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(showTPSLLines and inShortTrade ? entryPrice : na, "Short Entry", color=color.new(color.blue, 0), style=plot.style_linebr, linewidth=2)

// Trade Entry Markers with Labels
if showTradesOnChart and longSignal and not inLongTrade[1]
    label.new(bar_index, low, "LONG\n" + str.tostring(getLongEntryPrice(), "#.###"), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)

if showTradesOnChart and shortSignal and not inShortTrade[1]
    label.new(bar_index, high, "SHORT\n" + str.tostring(getShortEntryPrice(), "#.###"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// Trade Exit Markers - Show WIN (TP hit) or LOSS (SL hit)
if showTradesOnChart and longExitTP
    label.new(bar_index, high, "WIN ✓\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_down, color=color.new(#00c853, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and longExitSL
    label.new(bar_index, high, "LOSS ✗\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_down, color=color.new(#ff1744, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and shortExitTP
    label.new(bar_index, low, "WIN ✓\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_up, color=color.new(#00c853, 0), textcolor=color.white, size=size.small)

if showTradesOnChart and shortExitSL
    label.new(bar_index, low, "LOSS ✗\n" + str.tostring(exitPriceViz, "#.###"), style=label.style_label_up, color=color.new(#ff1744, 0), textcolor=color.white, size=size.small)

// =============================================================================
// DASHBOARD
// =============================================================================

if showDashboard and barstate.islast
    // Dashboard positioning
    tablePos = switch dashboardPosition
        "Top Right" => position.top_right
        "Top Left" => position.top_left
        "Bottom Right" => position.bottom_right
        "Bottom Left" => position.bottom_left
        => position.top_right

    tableSize = switch dashboardSize
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        "Large" => size.large
        => size.normal

    // Calculate statistics
    winrate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0.0
    avgWin = winningTrades > 0 ? grossProfit / winningTrades : 0.0
    avgLoss = losingTrades > 0 ? grossLoss / losingTrades : 0.0
    profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999.99 : 0.0
    returnPercent = ((currentCapital - initialCapital) / initialCapital) * 100
    expectancy = totalTrades > 0 ? totalProfitAmount / totalTrades : 0.0

    // Colors
    profitColor = totalProfitAmount >= 0 ? color.green : color.red
    winrateColor = winrate >= 50 ? color.green : color.orange
    drawdownColor = maxDrawdown < 10 ? color.green : maxDrawdown < 20 ? color.orange : color.red

    // Create table
    var table dashboard = table.new(tablePos, 2, 14, bgcolor=color.new(#1e222d, 10), border_color=color.new(#373a46, 0), border_width=1)

    // Header
    table.cell(dashboard, 0, 0, "BACKTESTER", text_color=color.white, text_size=tableSize, bgcolor=color.new(#2962ff, 20))
    table.cell(dashboard, 1, 0, "STATS", text_color=color.white, text_size=tableSize, bgcolor=color.new(#2962ff, 20))

    // Stats rows
    table.cell(dashboard, 0, 1, "Total Trades", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 1, str.tostring(totalTrades), text_color=color.white, text_size=tableSize)

    table.cell(dashboard, 0, 2, "Win Rate", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 2, str.tostring(winrate, "#.##") + "%", text_color=winrateColor, text_size=tableSize)

    table.cell(dashboard, 0, 3, "Wins / Losses", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 3, str.tostring(winningTrades) + " / " + str.tostring(losingTrades), text_color=color.white, text_size=tableSize)

    table.cell(dashboard, 0, 4, "Net Profit", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 4, str.tostring(totalProfitAmount, "#.##"), text_color=profitColor, text_size=tableSize)

    table.cell(dashboard, 0, 5, "Return %", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 5, str.tostring(returnPercent, "#.##") + "%", text_color=profitColor, text_size=tableSize)

    table.cell(dashboard, 0, 6, "Profit Factor", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 6, str.tostring(profitFactor, "#.##"), text_color=profitFactor >= 1 ? color.green : color.red, text_size=tableSize)

    table.cell(dashboard, 0, 7, "Max Drawdown", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 7, str.tostring(maxDrawdown, "#.##") + "%", text_color=drawdownColor, text_size=tableSize)

    table.cell(dashboard, 0, 8, "Avg Win", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 8, str.tostring(avgWin, "#.##"), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 9, "Avg Loss", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 9, str.tostring(avgLoss, "#.##"), text_color=color.red, text_size=tableSize)

    table.cell(dashboard, 0, 10, "Largest Win", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 10, str.tostring(largestWin, "#.##"), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 11, "Largest Loss", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 11, str.tostring(largestLoss, "#.##"), text_color=color.red, text_size=tableSize)

    table.cell(dashboard, 0, 12, "Max Consec. Wins", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 12, str.tostring(maxConsecutiveWins), text_color=color.green, text_size=tableSize)

    table.cell(dashboard, 0, 13, "Max Consec. Losses", text_color=color.gray, text_size=tableSize, text_halign=text.align_left)
    table.cell(dashboard, 1, 13, str.tostring(maxConsecutiveLosses), text_color=color.red, text_size=tableSize)

// =============================================================================
// EXPORT PLOTS (for connecting to other indicators)
// =============================================================================
// These can be used by other indicators to read the backtester state
plot(inLongTrade ? 1 : 0, "In Long Trade", display=display.none)
plot(inShortTrade ? 1 : 0, "In Short Trade", display=display.none)
plot(entryPrice, "Current Entry Price", display=display.none)
plot(tpPrice, "Current TP Price", display=display.none)
plot(slPrice, "Current SL Price", display=display.none)

// =============================================================================
// WEBHOOK EXPORT PLOTS (for Railway/Supabase integration)
// =============================================================================
// Ready State
plot(longReady ? 1 : 0, "Long Ready State", display=display.none)
plot(shortReady ? 1 : 0, "Short Ready State", display=display.none)

// Projected Entry/TP/SL (updated every bar while ready)
plot(projectedLongEntry, "Projected Long Entry", display=display.none)
plot(projectedLongTP, "Projected Long TP", display=display.none)
plot(projectedLongSL, "Projected Long SL", display=display.none)
plot(projectedShortEntry, "Projected Short Entry", display=display.none)
plot(projectedShortTP, "Projected Short TP", display=display.none)
plot(projectedShortSL, "Projected Short SL", display=display.none)

// ML Feature Exports
plot(atr, "ATR Value", display=display.none)
plot(longZoneWidth, "Long Zone Width (S1-S3)", display=display.none)
plot(shortZoneWidth, "Short Zone Width (R1-R3)", display=display.none)
plot(barsInLongReady, "Bars in Long Ready", display=display.none)
plot(barsInShortReady, "Bars in Short Ready", display=display.none)
plot(distanceToLongEntry, "Distance to Long Entry", display=display.none)
plot(distanceToShortEntry, "Distance to Short Entry", display=display.none)

// Trade outcome for ML (1 = win, -1 = loss, 0 = no exit)
tradeOutcome = longExitTP or shortExitTP ? 1 : longExitSL or shortExitSL ? -1 : 0
plot(tradeOutcome, "Trade Outcome", display=display.none)

// =============================================================================
// ALERT LOGIC (using alert() - 1 alert per chart covers everything)
// =============================================================================
// Ready state alerts (first entry into zone)
longReadyNew = longReady and not wasLongReady[1]
shortReadyNew = shortReady and not wasShortReady[1]

// In TradingView: Create 1 alert → Condition: "Universal Backtester" → "Any alert() function call"
// This single alert fires for READY, UPDATE, and TRIGGERED with the correct JSON each time.

if enableWebhookAlerts
    // READY - New setup detected
    if longReadyNew
        alert('{"type":"READY","direction":"LONG","coin":"' + syminfo.ticker + '","entry":' + str.tostring(projectedLongEntry) + ',"tp":' + str.tostring(projectedLongTP) + ',"sl":' + str.tostring(projectedLongSL) + ',"atr":' + str.tostring(atr) + ',"zoneWidth":' + str.tostring(longZoneWidth) + ',"time":"' + str.tostring(timenow) + '"}', alert.freq_once_per_bar_close)
    if shortReadyNew
        alert('{"type":"READY","direction":"SHORT","coin":"' + syminfo.ticker + '","entry":' + str.tostring(projectedShortEntry) + ',"tp":' + str.tostring(projectedShortTP) + ',"sl":' + str.tostring(projectedShortSL) + ',"atr":' + str.tostring(atr) + ',"zoneWidth":' + str.tostring(shortZoneWidth) + ',"time":"' + str.tostring(timenow) + '"}', alert.freq_once_per_bar_close)

    // UPDATE - Level update while in ready state (not on same bar as READY)
    if longReady and not longReadyNew
        alert('{"type":"UPDATE","direction":"LONG","coin":"' + syminfo.ticker + '","entry":' + str.tostring(projectedLongEntry) + ',"tp":' + str.tostring(projectedLongTP) + ',"sl":' + str.tostring(projectedLongSL) + ',"barsReady":' + str.tostring(barsInLongReady) + ',"time":"' + str.tostring(timenow) + '"}', alert.freq_once_per_bar_close)
    if shortReady and not shortReadyNew
        alert('{"type":"UPDATE","direction":"SHORT","coin":"' + syminfo.ticker + '","entry":' + str.tostring(projectedShortEntry) + ',"tp":' + str.tostring(projectedShortTP) + ',"sl":' + str.tostring(projectedShortSL) + ',"barsReady":' + str.tostring(barsInShortReady) + ',"time":"' + str.tostring(timenow) + '"}', alert.freq_once_per_bar_close)

    // TRIGGERED - Signal fired, place order now
    if longSignal
        alert('{"type":"TRIGGERED","direction":"LONG","coin":"' + syminfo.ticker + '","entry":' + str.tostring(entryPrice) + ',"tp":' + str.tostring(tpPrice) + ',"sl":' + str.tostring(slPrice) + ',"time":"' + str.tostring(timenow) + '"}', alert.freq_once_per_bar_close)
    if shortSignal
        alert('{"type":"TRIGGERED","direction":"SHORT","coin":"' + syminfo.ticker + '","entry":' + str.tostring(entryPrice) + ',"tp":' + str.tostring(tpPrice) + ',"sl":' + str.tostring(slPrice) + ',"time":"' + str.tostring(timenow) + '"}', alert.freq_once_per_bar_close)
